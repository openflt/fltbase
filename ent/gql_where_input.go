// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/openflt/fltbase/ent/airport"
	"github.com/openflt/fltbase/ent/city"
	"github.com/openflt/fltbase/ent/country"
	"github.com/openflt/fltbase/ent/predicate"
	"github.com/openflt/fltbase/ent/region"
	"github.com/openflt/fltbase/ent/state"
)

// AirportWhereInput represents a where input for filtering Airport queries.
type AirportWhereInput struct {
	Predicates []predicate.Airport  `json:"-"`
	Not        *AirportWhereInput   `json:"not,omitempty"`
	Or         []*AirportWhereInput `json:"or,omitempty"`
	And        []*AirportWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "site_id" field predicates.
	SiteID             *string  `json:"siteID,omitempty"`
	SiteIDNEQ          *string  `json:"siteIDNEQ,omitempty"`
	SiteIDIn           []string `json:"siteIDIn,omitempty"`
	SiteIDNotIn        []string `json:"siteIDNotIn,omitempty"`
	SiteIDGT           *string  `json:"siteIDGT,omitempty"`
	SiteIDGTE          *string  `json:"siteIDGTE,omitempty"`
	SiteIDLT           *string  `json:"siteIDLT,omitempty"`
	SiteIDLTE          *string  `json:"siteIDLTE,omitempty"`
	SiteIDContains     *string  `json:"siteIDContains,omitempty"`
	SiteIDHasPrefix    *string  `json:"siteIDHasPrefix,omitempty"`
	SiteIDHasSuffix    *string  `json:"siteIDHasSuffix,omitempty"`
	SiteIDEqualFold    *string  `json:"siteIDEqualFold,omitempty"`
	SiteIDContainsFold *string  `json:"siteIDContainsFold,omitempty"`

	// "facility_type" field predicates.
	FacilityType      *airport.FacilityType  `json:"facilityType,omitempty"`
	FacilityTypeNEQ   *airport.FacilityType  `json:"facilityTypeNEQ,omitempty"`
	FacilityTypeIn    []airport.FacilityType `json:"facilityTypeIn,omitempty"`
	FacilityTypeNotIn []airport.FacilityType `json:"facilityTypeNotIn,omitempty"`

	// "airport_id" field predicates.
	AirportID             *string  `json:"airportID,omitempty"`
	AirportIDNEQ          *string  `json:"airportIDNEQ,omitempty"`
	AirportIDIn           []string `json:"airportIDIn,omitempty"`
	AirportIDNotIn        []string `json:"airportIDNotIn,omitempty"`
	AirportIDGT           *string  `json:"airportIDGT,omitempty"`
	AirportIDGTE          *string  `json:"airportIDGTE,omitempty"`
	AirportIDLT           *string  `json:"airportIDLT,omitempty"`
	AirportIDLTE          *string  `json:"airportIDLTE,omitempty"`
	AirportIDContains     *string  `json:"airportIDContains,omitempty"`
	AirportIDHasPrefix    *string  `json:"airportIDHasPrefix,omitempty"`
	AirportIDHasSuffix    *string  `json:"airportIDHasSuffix,omitempty"`
	AirportIDEqualFold    *string  `json:"airportIDEqualFold,omitempty"`
	AirportIDContainsFold *string  `json:"airportIDContainsFold,omitempty"`

	// "ado_code" field predicates.
	AdoCode             *string  `json:"adoCode,omitempty"`
	AdoCodeNEQ          *string  `json:"adoCodeNEQ,omitempty"`
	AdoCodeIn           []string `json:"adoCodeIn,omitempty"`
	AdoCodeNotIn        []string `json:"adoCodeNotIn,omitempty"`
	AdoCodeGT           *string  `json:"adoCodeGT,omitempty"`
	AdoCodeGTE          *string  `json:"adoCodeGTE,omitempty"`
	AdoCodeLT           *string  `json:"adoCodeLT,omitempty"`
	AdoCodeLTE          *string  `json:"adoCodeLTE,omitempty"`
	AdoCodeContains     *string  `json:"adoCodeContains,omitempty"`
	AdoCodeHasPrefix    *string  `json:"adoCodeHasPrefix,omitempty"`
	AdoCodeHasSuffix    *string  `json:"adoCodeHasSuffix,omitempty"`
	AdoCodeEqualFold    *string  `json:"adoCodeEqualFold,omitempty"`
	AdoCodeContainsFold *string  `json:"adoCodeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "ownership_type" field predicates.
	OwnershipType      *airport.OwnershipType  `json:"ownershipType,omitempty"`
	OwnershipTypeNEQ   *airport.OwnershipType  `json:"ownershipTypeNEQ,omitempty"`
	OwnershipTypeIn    []airport.OwnershipType `json:"ownershipTypeIn,omitempty"`
	OwnershipTypeNotIn []airport.OwnershipType `json:"ownershipTypeNotIn,omitempty"`

	// "usage" field predicates.
	Usage      *airport.Usage  `json:"usage,omitempty"`
	UsageNEQ   *airport.Usage  `json:"usageNEQ,omitempty"`
	UsageIn    []airport.Usage `json:"usageIn,omitempty"`
	UsageNotIn []airport.Usage `json:"usageNotIn,omitempty"`

	// "latitude" field predicates.
	Latitude      *float32  `json:"latitude,omitempty"`
	LatitudeNEQ   *float32  `json:"latitudeNEQ,omitempty"`
	LatitudeIn    []float32 `json:"latitudeIn,omitempty"`
	LatitudeNotIn []float32 `json:"latitudeNotIn,omitempty"`
	LatitudeGT    *float32  `json:"latitudeGT,omitempty"`
	LatitudeGTE   *float32  `json:"latitudeGTE,omitempty"`
	LatitudeLT    *float32  `json:"latitudeLT,omitempty"`
	LatitudeLTE   *float32  `json:"latitudeLTE,omitempty"`

	// "longitude" field predicates.
	Longitude      *float32  `json:"longitude,omitempty"`
	LongitudeNEQ   *float32  `json:"longitudeNEQ,omitempty"`
	LongitudeIn    []float32 `json:"longitudeIn,omitempty"`
	LongitudeNotIn []float32 `json:"longitudeNotIn,omitempty"`
	LongitudeGT    *float32  `json:"longitudeGT,omitempty"`
	LongitudeGTE   *float32  `json:"longitudeGTE,omitempty"`
	LongitudeLT    *float32  `json:"longitudeLT,omitempty"`
	LongitudeLTE   *float32  `json:"longitudeLTE,omitempty"`

	// "location_survey_method" field predicates.
	LocationSurveyMethod      *airport.LocationSurveyMethod  `json:"locationSurveyMethod,omitempty"`
	LocationSurveyMethodNEQ   *airport.LocationSurveyMethod  `json:"locationSurveyMethodNEQ,omitempty"`
	LocationSurveyMethodIn    []airport.LocationSurveyMethod `json:"locationSurveyMethodIn,omitempty"`
	LocationSurveyMethodNotIn []airport.LocationSurveyMethod `json:"locationSurveyMethodNotIn,omitempty"`

	// "elevation" field predicates.
	Elevation      *float32  `json:"elevation,omitempty"`
	ElevationNEQ   *float32  `json:"elevationNEQ,omitempty"`
	ElevationIn    []float32 `json:"elevationIn,omitempty"`
	ElevationNotIn []float32 `json:"elevationNotIn,omitempty"`
	ElevationGT    *float32  `json:"elevationGT,omitempty"`
	ElevationGTE   *float32  `json:"elevationGTE,omitempty"`
	ElevationLT    *float32  `json:"elevationLT,omitempty"`
	ElevationLTE   *float32  `json:"elevationLTE,omitempty"`

	// "elevation_survey_method" field predicates.
	ElevationSurveyMethod      *airport.ElevationSurveyMethod  `json:"elevationSurveyMethod,omitempty"`
	ElevationSurveyMethodNEQ   *airport.ElevationSurveyMethod  `json:"elevationSurveyMethodNEQ,omitempty"`
	ElevationSurveyMethodIn    []airport.ElevationSurveyMethod `json:"elevationSurveyMethodIn,omitempty"`
	ElevationSurveyMethodNotIn []airport.ElevationSurveyMethod `json:"elevationSurveyMethodNotIn,omitempty"`

	// "magnetic_variance" field predicates.
	MagneticVariance      *int8  `json:"magneticVariance,omitempty"`
	MagneticVarianceNEQ   *int8  `json:"magneticVarianceNEQ,omitempty"`
	MagneticVarianceIn    []int8 `json:"magneticVarianceIn,omitempty"`
	MagneticVarianceNotIn []int8 `json:"magneticVarianceNotIn,omitempty"`
	MagneticVarianceGT    *int8  `json:"magneticVarianceGT,omitempty"`
	MagneticVarianceGTE   *int8  `json:"magneticVarianceGTE,omitempty"`
	MagneticVarianceLT    *int8  `json:"magneticVarianceLT,omitempty"`
	MagneticVarianceLTE   *int8  `json:"magneticVarianceLTE,omitempty"`

	// "magnetic_variance_year" field predicates.
	MagneticVarianceYear      *int8  `json:"magneticVarianceYear,omitempty"`
	MagneticVarianceYearNEQ   *int8  `json:"magneticVarianceYearNEQ,omitempty"`
	MagneticVarianceYearIn    []int8 `json:"magneticVarianceYearIn,omitempty"`
	MagneticVarianceYearNotIn []int8 `json:"magneticVarianceYearNotIn,omitempty"`
	MagneticVarianceYearGT    *int8  `json:"magneticVarianceYearGT,omitempty"`
	MagneticVarianceYearGTE   *int8  `json:"magneticVarianceYearGTE,omitempty"`
	MagneticVarianceYearLT    *int8  `json:"magneticVarianceYearLT,omitempty"`
	MagneticVarianceYearLTE   *int8  `json:"magneticVarianceYearLTE,omitempty"`

	// "traffic_pattern_altitude" field predicates.
	TrafficPatternAltitude      *int8  `json:"trafficPatternAltitude,omitempty"`
	TrafficPatternAltitudeNEQ   *int8  `json:"trafficPatternAltitudeNEQ,omitempty"`
	TrafficPatternAltitudeIn    []int8 `json:"trafficPatternAltitudeIn,omitempty"`
	TrafficPatternAltitudeNotIn []int8 `json:"trafficPatternAltitudeNotIn,omitempty"`
	TrafficPatternAltitudeGT    *int8  `json:"trafficPatternAltitudeGT,omitempty"`
	TrafficPatternAltitudeGTE   *int8  `json:"trafficPatternAltitudeGTE,omitempty"`
	TrafficPatternAltitudeLT    *int8  `json:"trafficPatternAltitudeLT,omitempty"`
	TrafficPatternAltitudeLTE   *int8  `json:"trafficPatternAltitudeLTE,omitempty"`

	// "chart_name" field predicates.
	ChartName             *string  `json:"chartName,omitempty"`
	ChartNameNEQ          *string  `json:"chartNameNEQ,omitempty"`
	ChartNameIn           []string `json:"chartNameIn,omitempty"`
	ChartNameNotIn        []string `json:"chartNameNotIn,omitempty"`
	ChartNameGT           *string  `json:"chartNameGT,omitempty"`
	ChartNameGTE          *string  `json:"chartNameGTE,omitempty"`
	ChartNameLT           *string  `json:"chartNameLT,omitempty"`
	ChartNameLTE          *string  `json:"chartNameLTE,omitempty"`
	ChartNameContains     *string  `json:"chartNameContains,omitempty"`
	ChartNameHasPrefix    *string  `json:"chartNameHasPrefix,omitempty"`
	ChartNameHasSuffix    *string  `json:"chartNameHasSuffix,omitempty"`
	ChartNameEqualFold    *string  `json:"chartNameEqualFold,omitempty"`
	ChartNameContainsFold *string  `json:"chartNameContainsFold,omitempty"`

	// "distance_to_city" field predicates.
	DistanceToCity      *uint8  `json:"distanceToCity,omitempty"`
	DistanceToCityNEQ   *uint8  `json:"distanceToCityNEQ,omitempty"`
	DistanceToCityIn    []uint8 `json:"distanceToCityIn,omitempty"`
	DistanceToCityNotIn []uint8 `json:"distanceToCityNotIn,omitempty"`
	DistanceToCityGT    *uint8  `json:"distanceToCityGT,omitempty"`
	DistanceToCityGTE   *uint8  `json:"distanceToCityGTE,omitempty"`
	DistanceToCityLT    *uint8  `json:"distanceToCityLT,omitempty"`
	DistanceToCityLTE   *uint8  `json:"distanceToCityLTE,omitempty"`

	// "direction_to_city" field predicates.
	DirectionToCity      *airport.DirectionToCity  `json:"directionToCity,omitempty"`
	DirectionToCityNEQ   *airport.DirectionToCity  `json:"directionToCityNEQ,omitempty"`
	DirectionToCityIn    []airport.DirectionToCity `json:"directionToCityIn,omitempty"`
	DirectionToCityNotIn []airport.DirectionToCity `json:"directionToCityNotIn,omitempty"`

	// "acreage" field predicates.
	Acreage      *uint8  `json:"acreage,omitempty"`
	AcreageNEQ   *uint8  `json:"acreageNEQ,omitempty"`
	AcreageIn    []uint8 `json:"acreageIn,omitempty"`
	AcreageNotIn []uint8 `json:"acreageNotIn,omitempty"`
	AcreageGT    *uint8  `json:"acreageGT,omitempty"`
	AcreageGTE   *uint8  `json:"acreageGTE,omitempty"`
	AcreageLT    *uint8  `json:"acreageLT,omitempty"`
	AcreageLTE   *uint8  `json:"acreageLTE,omitempty"`

	// "artcc_id" field predicates.
	ArtccID             *string  `json:"artccID,omitempty"`
	ArtccIDNEQ          *string  `json:"artccIDNEQ,omitempty"`
	ArtccIDIn           []string `json:"artccIDIn,omitempty"`
	ArtccIDNotIn        []string `json:"artccIDNotIn,omitempty"`
	ArtccIDGT           *string  `json:"artccIDGT,omitempty"`
	ArtccIDGTE          *string  `json:"artccIDGTE,omitempty"`
	ArtccIDLT           *string  `json:"artccIDLT,omitempty"`
	ArtccIDLTE          *string  `json:"artccIDLTE,omitempty"`
	ArtccIDContains     *string  `json:"artccIDContains,omitempty"`
	ArtccIDHasPrefix    *string  `json:"artccIDHasPrefix,omitempty"`
	ArtccIDHasSuffix    *string  `json:"artccIDHasSuffix,omitempty"`
	ArtccIDEqualFold    *string  `json:"artccIDEqualFold,omitempty"`
	ArtccIDContainsFold *string  `json:"artccIDContainsFold,omitempty"`

	// "artcc_name" field predicates.
	ArtccName             *string  `json:"artccName,omitempty"`
	ArtccNameNEQ          *string  `json:"artccNameNEQ,omitempty"`
	ArtccNameIn           []string `json:"artccNameIn,omitempty"`
	ArtccNameNotIn        []string `json:"artccNameNotIn,omitempty"`
	ArtccNameGT           *string  `json:"artccNameGT,omitempty"`
	ArtccNameGTE          *string  `json:"artccNameGTE,omitempty"`
	ArtccNameLT           *string  `json:"artccNameLT,omitempty"`
	ArtccNameLTE          *string  `json:"artccNameLTE,omitempty"`
	ArtccNameContains     *string  `json:"artccNameContains,omitempty"`
	ArtccNameHasPrefix    *string  `json:"artccNameHasPrefix,omitempty"`
	ArtccNameHasSuffix    *string  `json:"artccNameHasSuffix,omitempty"`
	ArtccNameEqualFold    *string  `json:"artccNameEqualFold,omitempty"`
	ArtccNameContainsFold *string  `json:"artccNameContainsFold,omitempty"`

	// "computer_id" field predicates.
	ComputerID             *string  `json:"computerID,omitempty"`
	ComputerIDNEQ          *string  `json:"computerIDNEQ,omitempty"`
	ComputerIDIn           []string `json:"computerIDIn,omitempty"`
	ComputerIDNotIn        []string `json:"computerIDNotIn,omitempty"`
	ComputerIDGT           *string  `json:"computerIDGT,omitempty"`
	ComputerIDGTE          *string  `json:"computerIDGTE,omitempty"`
	ComputerIDLT           *string  `json:"computerIDLT,omitempty"`
	ComputerIDLTE          *string  `json:"computerIDLTE,omitempty"`
	ComputerIDContains     *string  `json:"computerIDContains,omitempty"`
	ComputerIDHasPrefix    *string  `json:"computerIDHasPrefix,omitempty"`
	ComputerIDHasSuffix    *string  `json:"computerIDHasSuffix,omitempty"`
	ComputerIDEqualFold    *string  `json:"computerIDEqualFold,omitempty"`
	ComputerIDContainsFold *string  `json:"computerIDContainsFold,omitempty"`

	// "fss_on_airport" field predicates.
	FssOnAirport    *bool `json:"fssOnAirport,omitempty"`
	FssOnAirportNEQ *bool `json:"fssOnAirportNEQ,omitempty"`

	// "fss_id" field predicates.
	FssID             *string  `json:"fssID,omitempty"`
	FssIDNEQ          *string  `json:"fssIDNEQ,omitempty"`
	FssIDIn           []string `json:"fssIDIn,omitempty"`
	FssIDNotIn        []string `json:"fssIDNotIn,omitempty"`
	FssIDGT           *string  `json:"fssIDGT,omitempty"`
	FssIDGTE          *string  `json:"fssIDGTE,omitempty"`
	FssIDLT           *string  `json:"fssIDLT,omitempty"`
	FssIDLTE          *string  `json:"fssIDLTE,omitempty"`
	FssIDContains     *string  `json:"fssIDContains,omitempty"`
	FssIDHasPrefix    *string  `json:"fssIDHasPrefix,omitempty"`
	FssIDHasSuffix    *string  `json:"fssIDHasSuffix,omitempty"`
	FssIDEqualFold    *string  `json:"fssIDEqualFold,omitempty"`
	FssIDContainsFold *string  `json:"fssIDContainsFold,omitempty"`

	// "fss_name" field predicates.
	FssName             *string  `json:"fssName,omitempty"`
	FssNameNEQ          *string  `json:"fssNameNEQ,omitempty"`
	FssNameIn           []string `json:"fssNameIn,omitempty"`
	FssNameNotIn        []string `json:"fssNameNotIn,omitempty"`
	FssNameGT           *string  `json:"fssNameGT,omitempty"`
	FssNameGTE          *string  `json:"fssNameGTE,omitempty"`
	FssNameLT           *string  `json:"fssNameLT,omitempty"`
	FssNameLTE          *string  `json:"fssNameLTE,omitempty"`
	FssNameContains     *string  `json:"fssNameContains,omitempty"`
	FssNameHasPrefix    *string  `json:"fssNameHasPrefix,omitempty"`
	FssNameHasSuffix    *string  `json:"fssNameHasSuffix,omitempty"`
	FssNameEqualFold    *string  `json:"fssNameEqualFold,omitempty"`
	FssNameContainsFold *string  `json:"fssNameContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "toll_free_number" field predicates.
	TollFreeNumber             *string  `json:"tollFreeNumber,omitempty"`
	TollFreeNumberNEQ          *string  `json:"tollFreeNumberNEQ,omitempty"`
	TollFreeNumberIn           []string `json:"tollFreeNumberIn,omitempty"`
	TollFreeNumberNotIn        []string `json:"tollFreeNumberNotIn,omitempty"`
	TollFreeNumberGT           *string  `json:"tollFreeNumberGT,omitempty"`
	TollFreeNumberGTE          *string  `json:"tollFreeNumberGTE,omitempty"`
	TollFreeNumberLT           *string  `json:"tollFreeNumberLT,omitempty"`
	TollFreeNumberLTE          *string  `json:"tollFreeNumberLTE,omitempty"`
	TollFreeNumberContains     *string  `json:"tollFreeNumberContains,omitempty"`
	TollFreeNumberHasPrefix    *string  `json:"tollFreeNumberHasPrefix,omitempty"`
	TollFreeNumberHasSuffix    *string  `json:"tollFreeNumberHasSuffix,omitempty"`
	TollFreeNumberEqualFold    *string  `json:"tollFreeNumberEqualFold,omitempty"`
	TollFreeNumberContainsFold *string  `json:"tollFreeNumberContainsFold,omitempty"`

	// "alternate_fss_id" field predicates.
	AlternateFssID             *string  `json:"alternateFssID,omitempty"`
	AlternateFssIDNEQ          *string  `json:"alternateFssIDNEQ,omitempty"`
	AlternateFssIDIn           []string `json:"alternateFssIDIn,omitempty"`
	AlternateFssIDNotIn        []string `json:"alternateFssIDNotIn,omitempty"`
	AlternateFssIDGT           *string  `json:"alternateFssIDGT,omitempty"`
	AlternateFssIDGTE          *string  `json:"alternateFssIDGTE,omitempty"`
	AlternateFssIDLT           *string  `json:"alternateFssIDLT,omitempty"`
	AlternateFssIDLTE          *string  `json:"alternateFssIDLTE,omitempty"`
	AlternateFssIDContains     *string  `json:"alternateFssIDContains,omitempty"`
	AlternateFssIDHasPrefix    *string  `json:"alternateFssIDHasPrefix,omitempty"`
	AlternateFssIDHasSuffix    *string  `json:"alternateFssIDHasSuffix,omitempty"`
	AlternateFssIDEqualFold    *string  `json:"alternateFssIDEqualFold,omitempty"`
	AlternateFssIDContainsFold *string  `json:"alternateFssIDContainsFold,omitempty"`

	// "alternate_fss_name" field predicates.
	AlternateFssName             *string  `json:"alternateFssName,omitempty"`
	AlternateFssNameNEQ          *string  `json:"alternateFssNameNEQ,omitempty"`
	AlternateFssNameIn           []string `json:"alternateFssNameIn,omitempty"`
	AlternateFssNameNotIn        []string `json:"alternateFssNameNotIn,omitempty"`
	AlternateFssNameGT           *string  `json:"alternateFssNameGT,omitempty"`
	AlternateFssNameGTE          *string  `json:"alternateFssNameGTE,omitempty"`
	AlternateFssNameLT           *string  `json:"alternateFssNameLT,omitempty"`
	AlternateFssNameLTE          *string  `json:"alternateFssNameLTE,omitempty"`
	AlternateFssNameContains     *string  `json:"alternateFssNameContains,omitempty"`
	AlternateFssNameHasPrefix    *string  `json:"alternateFssNameHasPrefix,omitempty"`
	AlternateFssNameHasSuffix    *string  `json:"alternateFssNameHasSuffix,omitempty"`
	AlternateFssNameEqualFold    *string  `json:"alternateFssNameEqualFold,omitempty"`
	AlternateFssNameContainsFold *string  `json:"alternateFssNameContainsFold,omitempty"`

	// "alternate_toll_free_number" field predicates.
	AlternateTollFreeNumber             *string  `json:"alternateTollFreeNumber,omitempty"`
	AlternateTollFreeNumberNEQ          *string  `json:"alternateTollFreeNumberNEQ,omitempty"`
	AlternateTollFreeNumberIn           []string `json:"alternateTollFreeNumberIn,omitempty"`
	AlternateTollFreeNumberNotIn        []string `json:"alternateTollFreeNumberNotIn,omitempty"`
	AlternateTollFreeNumberGT           *string  `json:"alternateTollFreeNumberGT,omitempty"`
	AlternateTollFreeNumberGTE          *string  `json:"alternateTollFreeNumberGTE,omitempty"`
	AlternateTollFreeNumberLT           *string  `json:"alternateTollFreeNumberLT,omitempty"`
	AlternateTollFreeNumberLTE          *string  `json:"alternateTollFreeNumberLTE,omitempty"`
	AlternateTollFreeNumberContains     *string  `json:"alternateTollFreeNumberContains,omitempty"`
	AlternateTollFreeNumberHasPrefix    *string  `json:"alternateTollFreeNumberHasPrefix,omitempty"`
	AlternateTollFreeNumberHasSuffix    *string  `json:"alternateTollFreeNumberHasSuffix,omitempty"`
	AlternateTollFreeNumberEqualFold    *string  `json:"alternateTollFreeNumberEqualFold,omitempty"`
	AlternateTollFreeNumberContainsFold *string  `json:"alternateTollFreeNumberContainsFold,omitempty"`

	// "notam_id" field predicates.
	NotamID             *string  `json:"notamID,omitempty"`
	NotamIDNEQ          *string  `json:"notamIDNEQ,omitempty"`
	NotamIDIn           []string `json:"notamIDIn,omitempty"`
	NotamIDNotIn        []string `json:"notamIDNotIn,omitempty"`
	NotamIDGT           *string  `json:"notamIDGT,omitempty"`
	NotamIDGTE          *string  `json:"notamIDGTE,omitempty"`
	NotamIDLT           *string  `json:"notamIDLT,omitempty"`
	NotamIDLTE          *string  `json:"notamIDLTE,omitempty"`
	NotamIDContains     *string  `json:"notamIDContains,omitempty"`
	NotamIDHasPrefix    *string  `json:"notamIDHasPrefix,omitempty"`
	NotamIDHasSuffix    *string  `json:"notamIDHasSuffix,omitempty"`
	NotamIDEqualFold    *string  `json:"notamIDEqualFold,omitempty"`
	NotamIDContainsFold *string  `json:"notamIDContainsFold,omitempty"`

	// "notam_flag" field predicates.
	NotamFlag    *bool `json:"notamFlag,omitempty"`
	NotamFlagNEQ *bool `json:"notamFlagNEQ,omitempty"`

	// "activation_date" field predicates.
	ActivationDate      *time.Time  `json:"activationDate,omitempty"`
	ActivationDateNEQ   *time.Time  `json:"activationDateNEQ,omitempty"`
	ActivationDateIn    []time.Time `json:"activationDateIn,omitempty"`
	ActivationDateNotIn []time.Time `json:"activationDateNotIn,omitempty"`
	ActivationDateGT    *time.Time  `json:"activationDateGT,omitempty"`
	ActivationDateGTE   *time.Time  `json:"activationDateGTE,omitempty"`
	ActivationDateLT    *time.Time  `json:"activationDateLT,omitempty"`
	ActivationDateLTE   *time.Time  `json:"activationDateLTE,omitempty"`

	// "status" field predicates.
	Status      *airport.Status  `json:"status,omitempty"`
	StatusNEQ   *airport.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []airport.Status `json:"statusIn,omitempty"`
	StatusNotIn []airport.Status `json:"statusNotIn,omitempty"`

	// "state" edge predicates.
	HasState     *bool              `json:"hasState,omitempty"`
	HasStateWith []*StateWhereInput `json:"hasStateWith,omitempty"`

	// "city" edge predicates.
	HasCity     *bool             `json:"hasCity,omitempty"`
	HasCityWith []*CityWhereInput `json:"hasCityWith,omitempty"`

	// "region" edge predicates.
	HasRegion     *bool               `json:"hasRegion,omitempty"`
	HasRegionWith []*RegionWhereInput `json:"hasRegionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AirportWhereInput) AddPredicates(predicates ...predicate.Airport) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AirportWhereInput filter on the AirportQuery builder.
func (i *AirportWhereInput) Filter(q *AirportQuery) (*AirportQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAirportWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAirportWhereInput is returned in case the AirportWhereInput is empty.
var ErrEmptyAirportWhereInput = errors.New("ent: empty predicate AirportWhereInput")

// P returns a predicate for filtering airports.
// An error is returned if the input is empty or invalid.
func (i *AirportWhereInput) P() (predicate.Airport, error) {
	var predicates []predicate.Airport
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, airport.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Airport, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, airport.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Airport, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, airport.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, airport.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, airport.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, airport.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, airport.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, airport.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, airport.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, airport.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, airport.IDLTE(*i.IDLTE))
	}
	if i.SiteID != nil {
		predicates = append(predicates, airport.SiteIDEQ(*i.SiteID))
	}
	if i.SiteIDNEQ != nil {
		predicates = append(predicates, airport.SiteIDNEQ(*i.SiteIDNEQ))
	}
	if len(i.SiteIDIn) > 0 {
		predicates = append(predicates, airport.SiteIDIn(i.SiteIDIn...))
	}
	if len(i.SiteIDNotIn) > 0 {
		predicates = append(predicates, airport.SiteIDNotIn(i.SiteIDNotIn...))
	}
	if i.SiteIDGT != nil {
		predicates = append(predicates, airport.SiteIDGT(*i.SiteIDGT))
	}
	if i.SiteIDGTE != nil {
		predicates = append(predicates, airport.SiteIDGTE(*i.SiteIDGTE))
	}
	if i.SiteIDLT != nil {
		predicates = append(predicates, airport.SiteIDLT(*i.SiteIDLT))
	}
	if i.SiteIDLTE != nil {
		predicates = append(predicates, airport.SiteIDLTE(*i.SiteIDLTE))
	}
	if i.SiteIDContains != nil {
		predicates = append(predicates, airport.SiteIDContains(*i.SiteIDContains))
	}
	if i.SiteIDHasPrefix != nil {
		predicates = append(predicates, airport.SiteIDHasPrefix(*i.SiteIDHasPrefix))
	}
	if i.SiteIDHasSuffix != nil {
		predicates = append(predicates, airport.SiteIDHasSuffix(*i.SiteIDHasSuffix))
	}
	if i.SiteIDEqualFold != nil {
		predicates = append(predicates, airport.SiteIDEqualFold(*i.SiteIDEqualFold))
	}
	if i.SiteIDContainsFold != nil {
		predicates = append(predicates, airport.SiteIDContainsFold(*i.SiteIDContainsFold))
	}
	if i.FacilityType != nil {
		predicates = append(predicates, airport.FacilityTypeEQ(*i.FacilityType))
	}
	if i.FacilityTypeNEQ != nil {
		predicates = append(predicates, airport.FacilityTypeNEQ(*i.FacilityTypeNEQ))
	}
	if len(i.FacilityTypeIn) > 0 {
		predicates = append(predicates, airport.FacilityTypeIn(i.FacilityTypeIn...))
	}
	if len(i.FacilityTypeNotIn) > 0 {
		predicates = append(predicates, airport.FacilityTypeNotIn(i.FacilityTypeNotIn...))
	}
	if i.AirportID != nil {
		predicates = append(predicates, airport.AirportIDEQ(*i.AirportID))
	}
	if i.AirportIDNEQ != nil {
		predicates = append(predicates, airport.AirportIDNEQ(*i.AirportIDNEQ))
	}
	if len(i.AirportIDIn) > 0 {
		predicates = append(predicates, airport.AirportIDIn(i.AirportIDIn...))
	}
	if len(i.AirportIDNotIn) > 0 {
		predicates = append(predicates, airport.AirportIDNotIn(i.AirportIDNotIn...))
	}
	if i.AirportIDGT != nil {
		predicates = append(predicates, airport.AirportIDGT(*i.AirportIDGT))
	}
	if i.AirportIDGTE != nil {
		predicates = append(predicates, airport.AirportIDGTE(*i.AirportIDGTE))
	}
	if i.AirportIDLT != nil {
		predicates = append(predicates, airport.AirportIDLT(*i.AirportIDLT))
	}
	if i.AirportIDLTE != nil {
		predicates = append(predicates, airport.AirportIDLTE(*i.AirportIDLTE))
	}
	if i.AirportIDContains != nil {
		predicates = append(predicates, airport.AirportIDContains(*i.AirportIDContains))
	}
	if i.AirportIDHasPrefix != nil {
		predicates = append(predicates, airport.AirportIDHasPrefix(*i.AirportIDHasPrefix))
	}
	if i.AirportIDHasSuffix != nil {
		predicates = append(predicates, airport.AirportIDHasSuffix(*i.AirportIDHasSuffix))
	}
	if i.AirportIDEqualFold != nil {
		predicates = append(predicates, airport.AirportIDEqualFold(*i.AirportIDEqualFold))
	}
	if i.AirportIDContainsFold != nil {
		predicates = append(predicates, airport.AirportIDContainsFold(*i.AirportIDContainsFold))
	}
	if i.AdoCode != nil {
		predicates = append(predicates, airport.AdoCodeEQ(*i.AdoCode))
	}
	if i.AdoCodeNEQ != nil {
		predicates = append(predicates, airport.AdoCodeNEQ(*i.AdoCodeNEQ))
	}
	if len(i.AdoCodeIn) > 0 {
		predicates = append(predicates, airport.AdoCodeIn(i.AdoCodeIn...))
	}
	if len(i.AdoCodeNotIn) > 0 {
		predicates = append(predicates, airport.AdoCodeNotIn(i.AdoCodeNotIn...))
	}
	if i.AdoCodeGT != nil {
		predicates = append(predicates, airport.AdoCodeGT(*i.AdoCodeGT))
	}
	if i.AdoCodeGTE != nil {
		predicates = append(predicates, airport.AdoCodeGTE(*i.AdoCodeGTE))
	}
	if i.AdoCodeLT != nil {
		predicates = append(predicates, airport.AdoCodeLT(*i.AdoCodeLT))
	}
	if i.AdoCodeLTE != nil {
		predicates = append(predicates, airport.AdoCodeLTE(*i.AdoCodeLTE))
	}
	if i.AdoCodeContains != nil {
		predicates = append(predicates, airport.AdoCodeContains(*i.AdoCodeContains))
	}
	if i.AdoCodeHasPrefix != nil {
		predicates = append(predicates, airport.AdoCodeHasPrefix(*i.AdoCodeHasPrefix))
	}
	if i.AdoCodeHasSuffix != nil {
		predicates = append(predicates, airport.AdoCodeHasSuffix(*i.AdoCodeHasSuffix))
	}
	if i.AdoCodeEqualFold != nil {
		predicates = append(predicates, airport.AdoCodeEqualFold(*i.AdoCodeEqualFold))
	}
	if i.AdoCodeContainsFold != nil {
		predicates = append(predicates, airport.AdoCodeContainsFold(*i.AdoCodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, airport.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, airport.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, airport.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, airport.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, airport.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, airport.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, airport.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, airport.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, airport.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, airport.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, airport.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, airport.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, airport.NameContainsFold(*i.NameContainsFold))
	}
	if i.OwnershipType != nil {
		predicates = append(predicates, airport.OwnershipTypeEQ(*i.OwnershipType))
	}
	if i.OwnershipTypeNEQ != nil {
		predicates = append(predicates, airport.OwnershipTypeNEQ(*i.OwnershipTypeNEQ))
	}
	if len(i.OwnershipTypeIn) > 0 {
		predicates = append(predicates, airport.OwnershipTypeIn(i.OwnershipTypeIn...))
	}
	if len(i.OwnershipTypeNotIn) > 0 {
		predicates = append(predicates, airport.OwnershipTypeNotIn(i.OwnershipTypeNotIn...))
	}
	if i.Usage != nil {
		predicates = append(predicates, airport.UsageEQ(*i.Usage))
	}
	if i.UsageNEQ != nil {
		predicates = append(predicates, airport.UsageNEQ(*i.UsageNEQ))
	}
	if len(i.UsageIn) > 0 {
		predicates = append(predicates, airport.UsageIn(i.UsageIn...))
	}
	if len(i.UsageNotIn) > 0 {
		predicates = append(predicates, airport.UsageNotIn(i.UsageNotIn...))
	}
	if i.Latitude != nil {
		predicates = append(predicates, airport.LatitudeEQ(*i.Latitude))
	}
	if i.LatitudeNEQ != nil {
		predicates = append(predicates, airport.LatitudeNEQ(*i.LatitudeNEQ))
	}
	if len(i.LatitudeIn) > 0 {
		predicates = append(predicates, airport.LatitudeIn(i.LatitudeIn...))
	}
	if len(i.LatitudeNotIn) > 0 {
		predicates = append(predicates, airport.LatitudeNotIn(i.LatitudeNotIn...))
	}
	if i.LatitudeGT != nil {
		predicates = append(predicates, airport.LatitudeGT(*i.LatitudeGT))
	}
	if i.LatitudeGTE != nil {
		predicates = append(predicates, airport.LatitudeGTE(*i.LatitudeGTE))
	}
	if i.LatitudeLT != nil {
		predicates = append(predicates, airport.LatitudeLT(*i.LatitudeLT))
	}
	if i.LatitudeLTE != nil {
		predicates = append(predicates, airport.LatitudeLTE(*i.LatitudeLTE))
	}
	if i.Longitude != nil {
		predicates = append(predicates, airport.LongitudeEQ(*i.Longitude))
	}
	if i.LongitudeNEQ != nil {
		predicates = append(predicates, airport.LongitudeNEQ(*i.LongitudeNEQ))
	}
	if len(i.LongitudeIn) > 0 {
		predicates = append(predicates, airport.LongitudeIn(i.LongitudeIn...))
	}
	if len(i.LongitudeNotIn) > 0 {
		predicates = append(predicates, airport.LongitudeNotIn(i.LongitudeNotIn...))
	}
	if i.LongitudeGT != nil {
		predicates = append(predicates, airport.LongitudeGT(*i.LongitudeGT))
	}
	if i.LongitudeGTE != nil {
		predicates = append(predicates, airport.LongitudeGTE(*i.LongitudeGTE))
	}
	if i.LongitudeLT != nil {
		predicates = append(predicates, airport.LongitudeLT(*i.LongitudeLT))
	}
	if i.LongitudeLTE != nil {
		predicates = append(predicates, airport.LongitudeLTE(*i.LongitudeLTE))
	}
	if i.LocationSurveyMethod != nil {
		predicates = append(predicates, airport.LocationSurveyMethodEQ(*i.LocationSurveyMethod))
	}
	if i.LocationSurveyMethodNEQ != nil {
		predicates = append(predicates, airport.LocationSurveyMethodNEQ(*i.LocationSurveyMethodNEQ))
	}
	if len(i.LocationSurveyMethodIn) > 0 {
		predicates = append(predicates, airport.LocationSurveyMethodIn(i.LocationSurveyMethodIn...))
	}
	if len(i.LocationSurveyMethodNotIn) > 0 {
		predicates = append(predicates, airport.LocationSurveyMethodNotIn(i.LocationSurveyMethodNotIn...))
	}
	if i.Elevation != nil {
		predicates = append(predicates, airport.ElevationEQ(*i.Elevation))
	}
	if i.ElevationNEQ != nil {
		predicates = append(predicates, airport.ElevationNEQ(*i.ElevationNEQ))
	}
	if len(i.ElevationIn) > 0 {
		predicates = append(predicates, airport.ElevationIn(i.ElevationIn...))
	}
	if len(i.ElevationNotIn) > 0 {
		predicates = append(predicates, airport.ElevationNotIn(i.ElevationNotIn...))
	}
	if i.ElevationGT != nil {
		predicates = append(predicates, airport.ElevationGT(*i.ElevationGT))
	}
	if i.ElevationGTE != nil {
		predicates = append(predicates, airport.ElevationGTE(*i.ElevationGTE))
	}
	if i.ElevationLT != nil {
		predicates = append(predicates, airport.ElevationLT(*i.ElevationLT))
	}
	if i.ElevationLTE != nil {
		predicates = append(predicates, airport.ElevationLTE(*i.ElevationLTE))
	}
	if i.ElevationSurveyMethod != nil {
		predicates = append(predicates, airport.ElevationSurveyMethodEQ(*i.ElevationSurveyMethod))
	}
	if i.ElevationSurveyMethodNEQ != nil {
		predicates = append(predicates, airport.ElevationSurveyMethodNEQ(*i.ElevationSurveyMethodNEQ))
	}
	if len(i.ElevationSurveyMethodIn) > 0 {
		predicates = append(predicates, airport.ElevationSurveyMethodIn(i.ElevationSurveyMethodIn...))
	}
	if len(i.ElevationSurveyMethodNotIn) > 0 {
		predicates = append(predicates, airport.ElevationSurveyMethodNotIn(i.ElevationSurveyMethodNotIn...))
	}
	if i.MagneticVariance != nil {
		predicates = append(predicates, airport.MagneticVarianceEQ(*i.MagneticVariance))
	}
	if i.MagneticVarianceNEQ != nil {
		predicates = append(predicates, airport.MagneticVarianceNEQ(*i.MagneticVarianceNEQ))
	}
	if len(i.MagneticVarianceIn) > 0 {
		predicates = append(predicates, airport.MagneticVarianceIn(i.MagneticVarianceIn...))
	}
	if len(i.MagneticVarianceNotIn) > 0 {
		predicates = append(predicates, airport.MagneticVarianceNotIn(i.MagneticVarianceNotIn...))
	}
	if i.MagneticVarianceGT != nil {
		predicates = append(predicates, airport.MagneticVarianceGT(*i.MagneticVarianceGT))
	}
	if i.MagneticVarianceGTE != nil {
		predicates = append(predicates, airport.MagneticVarianceGTE(*i.MagneticVarianceGTE))
	}
	if i.MagneticVarianceLT != nil {
		predicates = append(predicates, airport.MagneticVarianceLT(*i.MagneticVarianceLT))
	}
	if i.MagneticVarianceLTE != nil {
		predicates = append(predicates, airport.MagneticVarianceLTE(*i.MagneticVarianceLTE))
	}
	if i.MagneticVarianceYear != nil {
		predicates = append(predicates, airport.MagneticVarianceYearEQ(*i.MagneticVarianceYear))
	}
	if i.MagneticVarianceYearNEQ != nil {
		predicates = append(predicates, airport.MagneticVarianceYearNEQ(*i.MagneticVarianceYearNEQ))
	}
	if len(i.MagneticVarianceYearIn) > 0 {
		predicates = append(predicates, airport.MagneticVarianceYearIn(i.MagneticVarianceYearIn...))
	}
	if len(i.MagneticVarianceYearNotIn) > 0 {
		predicates = append(predicates, airport.MagneticVarianceYearNotIn(i.MagneticVarianceYearNotIn...))
	}
	if i.MagneticVarianceYearGT != nil {
		predicates = append(predicates, airport.MagneticVarianceYearGT(*i.MagneticVarianceYearGT))
	}
	if i.MagneticVarianceYearGTE != nil {
		predicates = append(predicates, airport.MagneticVarianceYearGTE(*i.MagneticVarianceYearGTE))
	}
	if i.MagneticVarianceYearLT != nil {
		predicates = append(predicates, airport.MagneticVarianceYearLT(*i.MagneticVarianceYearLT))
	}
	if i.MagneticVarianceYearLTE != nil {
		predicates = append(predicates, airport.MagneticVarianceYearLTE(*i.MagneticVarianceYearLTE))
	}
	if i.TrafficPatternAltitude != nil {
		predicates = append(predicates, airport.TrafficPatternAltitudeEQ(*i.TrafficPatternAltitude))
	}
	if i.TrafficPatternAltitudeNEQ != nil {
		predicates = append(predicates, airport.TrafficPatternAltitudeNEQ(*i.TrafficPatternAltitudeNEQ))
	}
	if len(i.TrafficPatternAltitudeIn) > 0 {
		predicates = append(predicates, airport.TrafficPatternAltitudeIn(i.TrafficPatternAltitudeIn...))
	}
	if len(i.TrafficPatternAltitudeNotIn) > 0 {
		predicates = append(predicates, airport.TrafficPatternAltitudeNotIn(i.TrafficPatternAltitudeNotIn...))
	}
	if i.TrafficPatternAltitudeGT != nil {
		predicates = append(predicates, airport.TrafficPatternAltitudeGT(*i.TrafficPatternAltitudeGT))
	}
	if i.TrafficPatternAltitudeGTE != nil {
		predicates = append(predicates, airport.TrafficPatternAltitudeGTE(*i.TrafficPatternAltitudeGTE))
	}
	if i.TrafficPatternAltitudeLT != nil {
		predicates = append(predicates, airport.TrafficPatternAltitudeLT(*i.TrafficPatternAltitudeLT))
	}
	if i.TrafficPatternAltitudeLTE != nil {
		predicates = append(predicates, airport.TrafficPatternAltitudeLTE(*i.TrafficPatternAltitudeLTE))
	}
	if i.ChartName != nil {
		predicates = append(predicates, airport.ChartNameEQ(*i.ChartName))
	}
	if i.ChartNameNEQ != nil {
		predicates = append(predicates, airport.ChartNameNEQ(*i.ChartNameNEQ))
	}
	if len(i.ChartNameIn) > 0 {
		predicates = append(predicates, airport.ChartNameIn(i.ChartNameIn...))
	}
	if len(i.ChartNameNotIn) > 0 {
		predicates = append(predicates, airport.ChartNameNotIn(i.ChartNameNotIn...))
	}
	if i.ChartNameGT != nil {
		predicates = append(predicates, airport.ChartNameGT(*i.ChartNameGT))
	}
	if i.ChartNameGTE != nil {
		predicates = append(predicates, airport.ChartNameGTE(*i.ChartNameGTE))
	}
	if i.ChartNameLT != nil {
		predicates = append(predicates, airport.ChartNameLT(*i.ChartNameLT))
	}
	if i.ChartNameLTE != nil {
		predicates = append(predicates, airport.ChartNameLTE(*i.ChartNameLTE))
	}
	if i.ChartNameContains != nil {
		predicates = append(predicates, airport.ChartNameContains(*i.ChartNameContains))
	}
	if i.ChartNameHasPrefix != nil {
		predicates = append(predicates, airport.ChartNameHasPrefix(*i.ChartNameHasPrefix))
	}
	if i.ChartNameHasSuffix != nil {
		predicates = append(predicates, airport.ChartNameHasSuffix(*i.ChartNameHasSuffix))
	}
	if i.ChartNameEqualFold != nil {
		predicates = append(predicates, airport.ChartNameEqualFold(*i.ChartNameEqualFold))
	}
	if i.ChartNameContainsFold != nil {
		predicates = append(predicates, airport.ChartNameContainsFold(*i.ChartNameContainsFold))
	}
	if i.DistanceToCity != nil {
		predicates = append(predicates, airport.DistanceToCityEQ(*i.DistanceToCity))
	}
	if i.DistanceToCityNEQ != nil {
		predicates = append(predicates, airport.DistanceToCityNEQ(*i.DistanceToCityNEQ))
	}
	if len(i.DistanceToCityIn) > 0 {
		predicates = append(predicates, airport.DistanceToCityIn(i.DistanceToCityIn...))
	}
	if len(i.DistanceToCityNotIn) > 0 {
		predicates = append(predicates, airport.DistanceToCityNotIn(i.DistanceToCityNotIn...))
	}
	if i.DistanceToCityGT != nil {
		predicates = append(predicates, airport.DistanceToCityGT(*i.DistanceToCityGT))
	}
	if i.DistanceToCityGTE != nil {
		predicates = append(predicates, airport.DistanceToCityGTE(*i.DistanceToCityGTE))
	}
	if i.DistanceToCityLT != nil {
		predicates = append(predicates, airport.DistanceToCityLT(*i.DistanceToCityLT))
	}
	if i.DistanceToCityLTE != nil {
		predicates = append(predicates, airport.DistanceToCityLTE(*i.DistanceToCityLTE))
	}
	if i.DirectionToCity != nil {
		predicates = append(predicates, airport.DirectionToCityEQ(*i.DirectionToCity))
	}
	if i.DirectionToCityNEQ != nil {
		predicates = append(predicates, airport.DirectionToCityNEQ(*i.DirectionToCityNEQ))
	}
	if len(i.DirectionToCityIn) > 0 {
		predicates = append(predicates, airport.DirectionToCityIn(i.DirectionToCityIn...))
	}
	if len(i.DirectionToCityNotIn) > 0 {
		predicates = append(predicates, airport.DirectionToCityNotIn(i.DirectionToCityNotIn...))
	}
	if i.Acreage != nil {
		predicates = append(predicates, airport.AcreageEQ(*i.Acreage))
	}
	if i.AcreageNEQ != nil {
		predicates = append(predicates, airport.AcreageNEQ(*i.AcreageNEQ))
	}
	if len(i.AcreageIn) > 0 {
		predicates = append(predicates, airport.AcreageIn(i.AcreageIn...))
	}
	if len(i.AcreageNotIn) > 0 {
		predicates = append(predicates, airport.AcreageNotIn(i.AcreageNotIn...))
	}
	if i.AcreageGT != nil {
		predicates = append(predicates, airport.AcreageGT(*i.AcreageGT))
	}
	if i.AcreageGTE != nil {
		predicates = append(predicates, airport.AcreageGTE(*i.AcreageGTE))
	}
	if i.AcreageLT != nil {
		predicates = append(predicates, airport.AcreageLT(*i.AcreageLT))
	}
	if i.AcreageLTE != nil {
		predicates = append(predicates, airport.AcreageLTE(*i.AcreageLTE))
	}
	if i.ArtccID != nil {
		predicates = append(predicates, airport.ArtccIDEQ(*i.ArtccID))
	}
	if i.ArtccIDNEQ != nil {
		predicates = append(predicates, airport.ArtccIDNEQ(*i.ArtccIDNEQ))
	}
	if len(i.ArtccIDIn) > 0 {
		predicates = append(predicates, airport.ArtccIDIn(i.ArtccIDIn...))
	}
	if len(i.ArtccIDNotIn) > 0 {
		predicates = append(predicates, airport.ArtccIDNotIn(i.ArtccIDNotIn...))
	}
	if i.ArtccIDGT != nil {
		predicates = append(predicates, airport.ArtccIDGT(*i.ArtccIDGT))
	}
	if i.ArtccIDGTE != nil {
		predicates = append(predicates, airport.ArtccIDGTE(*i.ArtccIDGTE))
	}
	if i.ArtccIDLT != nil {
		predicates = append(predicates, airport.ArtccIDLT(*i.ArtccIDLT))
	}
	if i.ArtccIDLTE != nil {
		predicates = append(predicates, airport.ArtccIDLTE(*i.ArtccIDLTE))
	}
	if i.ArtccIDContains != nil {
		predicates = append(predicates, airport.ArtccIDContains(*i.ArtccIDContains))
	}
	if i.ArtccIDHasPrefix != nil {
		predicates = append(predicates, airport.ArtccIDHasPrefix(*i.ArtccIDHasPrefix))
	}
	if i.ArtccIDHasSuffix != nil {
		predicates = append(predicates, airport.ArtccIDHasSuffix(*i.ArtccIDHasSuffix))
	}
	if i.ArtccIDEqualFold != nil {
		predicates = append(predicates, airport.ArtccIDEqualFold(*i.ArtccIDEqualFold))
	}
	if i.ArtccIDContainsFold != nil {
		predicates = append(predicates, airport.ArtccIDContainsFold(*i.ArtccIDContainsFold))
	}
	if i.ArtccName != nil {
		predicates = append(predicates, airport.ArtccNameEQ(*i.ArtccName))
	}
	if i.ArtccNameNEQ != nil {
		predicates = append(predicates, airport.ArtccNameNEQ(*i.ArtccNameNEQ))
	}
	if len(i.ArtccNameIn) > 0 {
		predicates = append(predicates, airport.ArtccNameIn(i.ArtccNameIn...))
	}
	if len(i.ArtccNameNotIn) > 0 {
		predicates = append(predicates, airport.ArtccNameNotIn(i.ArtccNameNotIn...))
	}
	if i.ArtccNameGT != nil {
		predicates = append(predicates, airport.ArtccNameGT(*i.ArtccNameGT))
	}
	if i.ArtccNameGTE != nil {
		predicates = append(predicates, airport.ArtccNameGTE(*i.ArtccNameGTE))
	}
	if i.ArtccNameLT != nil {
		predicates = append(predicates, airport.ArtccNameLT(*i.ArtccNameLT))
	}
	if i.ArtccNameLTE != nil {
		predicates = append(predicates, airport.ArtccNameLTE(*i.ArtccNameLTE))
	}
	if i.ArtccNameContains != nil {
		predicates = append(predicates, airport.ArtccNameContains(*i.ArtccNameContains))
	}
	if i.ArtccNameHasPrefix != nil {
		predicates = append(predicates, airport.ArtccNameHasPrefix(*i.ArtccNameHasPrefix))
	}
	if i.ArtccNameHasSuffix != nil {
		predicates = append(predicates, airport.ArtccNameHasSuffix(*i.ArtccNameHasSuffix))
	}
	if i.ArtccNameEqualFold != nil {
		predicates = append(predicates, airport.ArtccNameEqualFold(*i.ArtccNameEqualFold))
	}
	if i.ArtccNameContainsFold != nil {
		predicates = append(predicates, airport.ArtccNameContainsFold(*i.ArtccNameContainsFold))
	}
	if i.ComputerID != nil {
		predicates = append(predicates, airport.ComputerIDEQ(*i.ComputerID))
	}
	if i.ComputerIDNEQ != nil {
		predicates = append(predicates, airport.ComputerIDNEQ(*i.ComputerIDNEQ))
	}
	if len(i.ComputerIDIn) > 0 {
		predicates = append(predicates, airport.ComputerIDIn(i.ComputerIDIn...))
	}
	if len(i.ComputerIDNotIn) > 0 {
		predicates = append(predicates, airport.ComputerIDNotIn(i.ComputerIDNotIn...))
	}
	if i.ComputerIDGT != nil {
		predicates = append(predicates, airport.ComputerIDGT(*i.ComputerIDGT))
	}
	if i.ComputerIDGTE != nil {
		predicates = append(predicates, airport.ComputerIDGTE(*i.ComputerIDGTE))
	}
	if i.ComputerIDLT != nil {
		predicates = append(predicates, airport.ComputerIDLT(*i.ComputerIDLT))
	}
	if i.ComputerIDLTE != nil {
		predicates = append(predicates, airport.ComputerIDLTE(*i.ComputerIDLTE))
	}
	if i.ComputerIDContains != nil {
		predicates = append(predicates, airport.ComputerIDContains(*i.ComputerIDContains))
	}
	if i.ComputerIDHasPrefix != nil {
		predicates = append(predicates, airport.ComputerIDHasPrefix(*i.ComputerIDHasPrefix))
	}
	if i.ComputerIDHasSuffix != nil {
		predicates = append(predicates, airport.ComputerIDHasSuffix(*i.ComputerIDHasSuffix))
	}
	if i.ComputerIDEqualFold != nil {
		predicates = append(predicates, airport.ComputerIDEqualFold(*i.ComputerIDEqualFold))
	}
	if i.ComputerIDContainsFold != nil {
		predicates = append(predicates, airport.ComputerIDContainsFold(*i.ComputerIDContainsFold))
	}
	if i.FssOnAirport != nil {
		predicates = append(predicates, airport.FssOnAirportEQ(*i.FssOnAirport))
	}
	if i.FssOnAirportNEQ != nil {
		predicates = append(predicates, airport.FssOnAirportNEQ(*i.FssOnAirportNEQ))
	}
	if i.FssID != nil {
		predicates = append(predicates, airport.FssIDEQ(*i.FssID))
	}
	if i.FssIDNEQ != nil {
		predicates = append(predicates, airport.FssIDNEQ(*i.FssIDNEQ))
	}
	if len(i.FssIDIn) > 0 {
		predicates = append(predicates, airport.FssIDIn(i.FssIDIn...))
	}
	if len(i.FssIDNotIn) > 0 {
		predicates = append(predicates, airport.FssIDNotIn(i.FssIDNotIn...))
	}
	if i.FssIDGT != nil {
		predicates = append(predicates, airport.FssIDGT(*i.FssIDGT))
	}
	if i.FssIDGTE != nil {
		predicates = append(predicates, airport.FssIDGTE(*i.FssIDGTE))
	}
	if i.FssIDLT != nil {
		predicates = append(predicates, airport.FssIDLT(*i.FssIDLT))
	}
	if i.FssIDLTE != nil {
		predicates = append(predicates, airport.FssIDLTE(*i.FssIDLTE))
	}
	if i.FssIDContains != nil {
		predicates = append(predicates, airport.FssIDContains(*i.FssIDContains))
	}
	if i.FssIDHasPrefix != nil {
		predicates = append(predicates, airport.FssIDHasPrefix(*i.FssIDHasPrefix))
	}
	if i.FssIDHasSuffix != nil {
		predicates = append(predicates, airport.FssIDHasSuffix(*i.FssIDHasSuffix))
	}
	if i.FssIDEqualFold != nil {
		predicates = append(predicates, airport.FssIDEqualFold(*i.FssIDEqualFold))
	}
	if i.FssIDContainsFold != nil {
		predicates = append(predicates, airport.FssIDContainsFold(*i.FssIDContainsFold))
	}
	if i.FssName != nil {
		predicates = append(predicates, airport.FssNameEQ(*i.FssName))
	}
	if i.FssNameNEQ != nil {
		predicates = append(predicates, airport.FssNameNEQ(*i.FssNameNEQ))
	}
	if len(i.FssNameIn) > 0 {
		predicates = append(predicates, airport.FssNameIn(i.FssNameIn...))
	}
	if len(i.FssNameNotIn) > 0 {
		predicates = append(predicates, airport.FssNameNotIn(i.FssNameNotIn...))
	}
	if i.FssNameGT != nil {
		predicates = append(predicates, airport.FssNameGT(*i.FssNameGT))
	}
	if i.FssNameGTE != nil {
		predicates = append(predicates, airport.FssNameGTE(*i.FssNameGTE))
	}
	if i.FssNameLT != nil {
		predicates = append(predicates, airport.FssNameLT(*i.FssNameLT))
	}
	if i.FssNameLTE != nil {
		predicates = append(predicates, airport.FssNameLTE(*i.FssNameLTE))
	}
	if i.FssNameContains != nil {
		predicates = append(predicates, airport.FssNameContains(*i.FssNameContains))
	}
	if i.FssNameHasPrefix != nil {
		predicates = append(predicates, airport.FssNameHasPrefix(*i.FssNameHasPrefix))
	}
	if i.FssNameHasSuffix != nil {
		predicates = append(predicates, airport.FssNameHasSuffix(*i.FssNameHasSuffix))
	}
	if i.FssNameEqualFold != nil {
		predicates = append(predicates, airport.FssNameEqualFold(*i.FssNameEqualFold))
	}
	if i.FssNameContainsFold != nil {
		predicates = append(predicates, airport.FssNameContainsFold(*i.FssNameContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, airport.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, airport.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, airport.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, airport.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, airport.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, airport.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, airport.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, airport.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, airport.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, airport.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, airport.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, airport.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, airport.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.TollFreeNumber != nil {
		predicates = append(predicates, airport.TollFreeNumberEQ(*i.TollFreeNumber))
	}
	if i.TollFreeNumberNEQ != nil {
		predicates = append(predicates, airport.TollFreeNumberNEQ(*i.TollFreeNumberNEQ))
	}
	if len(i.TollFreeNumberIn) > 0 {
		predicates = append(predicates, airport.TollFreeNumberIn(i.TollFreeNumberIn...))
	}
	if len(i.TollFreeNumberNotIn) > 0 {
		predicates = append(predicates, airport.TollFreeNumberNotIn(i.TollFreeNumberNotIn...))
	}
	if i.TollFreeNumberGT != nil {
		predicates = append(predicates, airport.TollFreeNumberGT(*i.TollFreeNumberGT))
	}
	if i.TollFreeNumberGTE != nil {
		predicates = append(predicates, airport.TollFreeNumberGTE(*i.TollFreeNumberGTE))
	}
	if i.TollFreeNumberLT != nil {
		predicates = append(predicates, airport.TollFreeNumberLT(*i.TollFreeNumberLT))
	}
	if i.TollFreeNumberLTE != nil {
		predicates = append(predicates, airport.TollFreeNumberLTE(*i.TollFreeNumberLTE))
	}
	if i.TollFreeNumberContains != nil {
		predicates = append(predicates, airport.TollFreeNumberContains(*i.TollFreeNumberContains))
	}
	if i.TollFreeNumberHasPrefix != nil {
		predicates = append(predicates, airport.TollFreeNumberHasPrefix(*i.TollFreeNumberHasPrefix))
	}
	if i.TollFreeNumberHasSuffix != nil {
		predicates = append(predicates, airport.TollFreeNumberHasSuffix(*i.TollFreeNumberHasSuffix))
	}
	if i.TollFreeNumberEqualFold != nil {
		predicates = append(predicates, airport.TollFreeNumberEqualFold(*i.TollFreeNumberEqualFold))
	}
	if i.TollFreeNumberContainsFold != nil {
		predicates = append(predicates, airport.TollFreeNumberContainsFold(*i.TollFreeNumberContainsFold))
	}
	if i.AlternateFssID != nil {
		predicates = append(predicates, airport.AlternateFssIDEQ(*i.AlternateFssID))
	}
	if i.AlternateFssIDNEQ != nil {
		predicates = append(predicates, airport.AlternateFssIDNEQ(*i.AlternateFssIDNEQ))
	}
	if len(i.AlternateFssIDIn) > 0 {
		predicates = append(predicates, airport.AlternateFssIDIn(i.AlternateFssIDIn...))
	}
	if len(i.AlternateFssIDNotIn) > 0 {
		predicates = append(predicates, airport.AlternateFssIDNotIn(i.AlternateFssIDNotIn...))
	}
	if i.AlternateFssIDGT != nil {
		predicates = append(predicates, airport.AlternateFssIDGT(*i.AlternateFssIDGT))
	}
	if i.AlternateFssIDGTE != nil {
		predicates = append(predicates, airport.AlternateFssIDGTE(*i.AlternateFssIDGTE))
	}
	if i.AlternateFssIDLT != nil {
		predicates = append(predicates, airport.AlternateFssIDLT(*i.AlternateFssIDLT))
	}
	if i.AlternateFssIDLTE != nil {
		predicates = append(predicates, airport.AlternateFssIDLTE(*i.AlternateFssIDLTE))
	}
	if i.AlternateFssIDContains != nil {
		predicates = append(predicates, airport.AlternateFssIDContains(*i.AlternateFssIDContains))
	}
	if i.AlternateFssIDHasPrefix != nil {
		predicates = append(predicates, airport.AlternateFssIDHasPrefix(*i.AlternateFssIDHasPrefix))
	}
	if i.AlternateFssIDHasSuffix != nil {
		predicates = append(predicates, airport.AlternateFssIDHasSuffix(*i.AlternateFssIDHasSuffix))
	}
	if i.AlternateFssIDEqualFold != nil {
		predicates = append(predicates, airport.AlternateFssIDEqualFold(*i.AlternateFssIDEqualFold))
	}
	if i.AlternateFssIDContainsFold != nil {
		predicates = append(predicates, airport.AlternateFssIDContainsFold(*i.AlternateFssIDContainsFold))
	}
	if i.AlternateFssName != nil {
		predicates = append(predicates, airport.AlternateFssNameEQ(*i.AlternateFssName))
	}
	if i.AlternateFssNameNEQ != nil {
		predicates = append(predicates, airport.AlternateFssNameNEQ(*i.AlternateFssNameNEQ))
	}
	if len(i.AlternateFssNameIn) > 0 {
		predicates = append(predicates, airport.AlternateFssNameIn(i.AlternateFssNameIn...))
	}
	if len(i.AlternateFssNameNotIn) > 0 {
		predicates = append(predicates, airport.AlternateFssNameNotIn(i.AlternateFssNameNotIn...))
	}
	if i.AlternateFssNameGT != nil {
		predicates = append(predicates, airport.AlternateFssNameGT(*i.AlternateFssNameGT))
	}
	if i.AlternateFssNameGTE != nil {
		predicates = append(predicates, airport.AlternateFssNameGTE(*i.AlternateFssNameGTE))
	}
	if i.AlternateFssNameLT != nil {
		predicates = append(predicates, airport.AlternateFssNameLT(*i.AlternateFssNameLT))
	}
	if i.AlternateFssNameLTE != nil {
		predicates = append(predicates, airport.AlternateFssNameLTE(*i.AlternateFssNameLTE))
	}
	if i.AlternateFssNameContains != nil {
		predicates = append(predicates, airport.AlternateFssNameContains(*i.AlternateFssNameContains))
	}
	if i.AlternateFssNameHasPrefix != nil {
		predicates = append(predicates, airport.AlternateFssNameHasPrefix(*i.AlternateFssNameHasPrefix))
	}
	if i.AlternateFssNameHasSuffix != nil {
		predicates = append(predicates, airport.AlternateFssNameHasSuffix(*i.AlternateFssNameHasSuffix))
	}
	if i.AlternateFssNameEqualFold != nil {
		predicates = append(predicates, airport.AlternateFssNameEqualFold(*i.AlternateFssNameEqualFold))
	}
	if i.AlternateFssNameContainsFold != nil {
		predicates = append(predicates, airport.AlternateFssNameContainsFold(*i.AlternateFssNameContainsFold))
	}
	if i.AlternateTollFreeNumber != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberEQ(*i.AlternateTollFreeNumber))
	}
	if i.AlternateTollFreeNumberNEQ != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberNEQ(*i.AlternateTollFreeNumberNEQ))
	}
	if len(i.AlternateTollFreeNumberIn) > 0 {
		predicates = append(predicates, airport.AlternateTollFreeNumberIn(i.AlternateTollFreeNumberIn...))
	}
	if len(i.AlternateTollFreeNumberNotIn) > 0 {
		predicates = append(predicates, airport.AlternateTollFreeNumberNotIn(i.AlternateTollFreeNumberNotIn...))
	}
	if i.AlternateTollFreeNumberGT != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberGT(*i.AlternateTollFreeNumberGT))
	}
	if i.AlternateTollFreeNumberGTE != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberGTE(*i.AlternateTollFreeNumberGTE))
	}
	if i.AlternateTollFreeNumberLT != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberLT(*i.AlternateTollFreeNumberLT))
	}
	if i.AlternateTollFreeNumberLTE != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberLTE(*i.AlternateTollFreeNumberLTE))
	}
	if i.AlternateTollFreeNumberContains != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberContains(*i.AlternateTollFreeNumberContains))
	}
	if i.AlternateTollFreeNumberHasPrefix != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberHasPrefix(*i.AlternateTollFreeNumberHasPrefix))
	}
	if i.AlternateTollFreeNumberHasSuffix != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberHasSuffix(*i.AlternateTollFreeNumberHasSuffix))
	}
	if i.AlternateTollFreeNumberEqualFold != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberEqualFold(*i.AlternateTollFreeNumberEqualFold))
	}
	if i.AlternateTollFreeNumberContainsFold != nil {
		predicates = append(predicates, airport.AlternateTollFreeNumberContainsFold(*i.AlternateTollFreeNumberContainsFold))
	}
	if i.NotamID != nil {
		predicates = append(predicates, airport.NotamIDEQ(*i.NotamID))
	}
	if i.NotamIDNEQ != nil {
		predicates = append(predicates, airport.NotamIDNEQ(*i.NotamIDNEQ))
	}
	if len(i.NotamIDIn) > 0 {
		predicates = append(predicates, airport.NotamIDIn(i.NotamIDIn...))
	}
	if len(i.NotamIDNotIn) > 0 {
		predicates = append(predicates, airport.NotamIDNotIn(i.NotamIDNotIn...))
	}
	if i.NotamIDGT != nil {
		predicates = append(predicates, airport.NotamIDGT(*i.NotamIDGT))
	}
	if i.NotamIDGTE != nil {
		predicates = append(predicates, airport.NotamIDGTE(*i.NotamIDGTE))
	}
	if i.NotamIDLT != nil {
		predicates = append(predicates, airport.NotamIDLT(*i.NotamIDLT))
	}
	if i.NotamIDLTE != nil {
		predicates = append(predicates, airport.NotamIDLTE(*i.NotamIDLTE))
	}
	if i.NotamIDContains != nil {
		predicates = append(predicates, airport.NotamIDContains(*i.NotamIDContains))
	}
	if i.NotamIDHasPrefix != nil {
		predicates = append(predicates, airport.NotamIDHasPrefix(*i.NotamIDHasPrefix))
	}
	if i.NotamIDHasSuffix != nil {
		predicates = append(predicates, airport.NotamIDHasSuffix(*i.NotamIDHasSuffix))
	}
	if i.NotamIDEqualFold != nil {
		predicates = append(predicates, airport.NotamIDEqualFold(*i.NotamIDEqualFold))
	}
	if i.NotamIDContainsFold != nil {
		predicates = append(predicates, airport.NotamIDContainsFold(*i.NotamIDContainsFold))
	}
	if i.NotamFlag != nil {
		predicates = append(predicates, airport.NotamFlagEQ(*i.NotamFlag))
	}
	if i.NotamFlagNEQ != nil {
		predicates = append(predicates, airport.NotamFlagNEQ(*i.NotamFlagNEQ))
	}
	if i.ActivationDate != nil {
		predicates = append(predicates, airport.ActivationDateEQ(*i.ActivationDate))
	}
	if i.ActivationDateNEQ != nil {
		predicates = append(predicates, airport.ActivationDateNEQ(*i.ActivationDateNEQ))
	}
	if len(i.ActivationDateIn) > 0 {
		predicates = append(predicates, airport.ActivationDateIn(i.ActivationDateIn...))
	}
	if len(i.ActivationDateNotIn) > 0 {
		predicates = append(predicates, airport.ActivationDateNotIn(i.ActivationDateNotIn...))
	}
	if i.ActivationDateGT != nil {
		predicates = append(predicates, airport.ActivationDateGT(*i.ActivationDateGT))
	}
	if i.ActivationDateGTE != nil {
		predicates = append(predicates, airport.ActivationDateGTE(*i.ActivationDateGTE))
	}
	if i.ActivationDateLT != nil {
		predicates = append(predicates, airport.ActivationDateLT(*i.ActivationDateLT))
	}
	if i.ActivationDateLTE != nil {
		predicates = append(predicates, airport.ActivationDateLTE(*i.ActivationDateLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, airport.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, airport.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, airport.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, airport.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasState != nil {
		p := airport.HasState()
		if !*i.HasState {
			p = airport.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStateWith) > 0 {
		with := make([]predicate.State, 0, len(i.HasStateWith))
		for _, w := range i.HasStateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, airport.HasStateWith(with...))
	}
	if i.HasCity != nil {
		p := airport.HasCity()
		if !*i.HasCity {
			p = airport.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCityWith) > 0 {
		with := make([]predicate.City, 0, len(i.HasCityWith))
		for _, w := range i.HasCityWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCityWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, airport.HasCityWith(with...))
	}
	if i.HasRegion != nil {
		p := airport.HasRegion()
		if !*i.HasRegion {
			p = airport.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRegionWith) > 0 {
		with := make([]predicate.Region, 0, len(i.HasRegionWith))
		for _, w := range i.HasRegionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRegionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, airport.HasRegionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAirportWhereInput
	case 1:
		return predicates[0], nil
	default:
		return airport.And(predicates...), nil
	}
}

// CityWhereInput represents a where input for filtering City queries.
type CityWhereInput struct {
	Predicates []predicate.City  `json:"-"`
	Not        *CityWhereInput   `json:"not,omitempty"`
	Or         []*CityWhereInput `json:"or,omitempty"`
	And        []*CityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "state" edge predicates.
	HasState     *bool              `json:"hasState,omitempty"`
	HasStateWith []*StateWhereInput `json:"hasStateWith,omitempty"`

	// "airports" edge predicates.
	HasAirports     *bool                `json:"hasAirports,omitempty"`
	HasAirportsWith []*AirportWhereInput `json:"hasAirportsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CityWhereInput) AddPredicates(predicates ...predicate.City) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CityWhereInput filter on the CityQuery builder.
func (i *CityWhereInput) Filter(q *CityQuery) (*CityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCityWhereInput is returned in case the CityWhereInput is empty.
var ErrEmptyCityWhereInput = errors.New("ent: empty predicate CityWhereInput")

// P returns a predicate for filtering cities.
// An error is returned if the input is empty or invalid.
func (i *CityWhereInput) P() (predicate.City, error) {
	var predicates []predicate.City
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, city.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.City, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, city.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.City, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, city.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, city.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, city.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, city.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, city.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, city.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, city.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, city.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, city.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, city.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, city.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, city.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, city.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, city.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, city.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, city.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, city.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, city.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, city.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, city.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, city.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, city.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasState != nil {
		p := city.HasState()
		if !*i.HasState {
			p = city.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStateWith) > 0 {
		with := make([]predicate.State, 0, len(i.HasStateWith))
		for _, w := range i.HasStateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, city.HasStateWith(with...))
	}
	if i.HasAirports != nil {
		p := city.HasAirports()
		if !*i.HasAirports {
			p = city.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAirportsWith) > 0 {
		with := make([]predicate.Airport, 0, len(i.HasAirportsWith))
		for _, w := range i.HasAirportsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAirportsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, city.HasAirportsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return city.And(predicates...), nil
	}
}

// CountryWhereInput represents a where input for filtering Country queries.
type CountryWhereInput struct {
	Predicates []predicate.Country  `json:"-"`
	Not        *CountryWhereInput   `json:"not,omitempty"`
	Or         []*CountryWhereInput `json:"or,omitempty"`
	And        []*CountryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CountryWhereInput) AddPredicates(predicates ...predicate.Country) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CountryWhereInput filter on the CountryQuery builder.
func (i *CountryWhereInput) Filter(q *CountryQuery) (*CountryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCountryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCountryWhereInput is returned in case the CountryWhereInput is empty.
var ErrEmptyCountryWhereInput = errors.New("ent: empty predicate CountryWhereInput")

// P returns a predicate for filtering countries.
// An error is returned if the input is empty or invalid.
func (i *CountryWhereInput) P() (predicate.Country, error) {
	var predicates []predicate.Country
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, country.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Country, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, country.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Country, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, country.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, country.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, country.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, country.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, country.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, country.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, country.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, country.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, country.IDLTE(*i.IDLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, country.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, country.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, country.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, country.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, country.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, country.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, country.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, country.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, country.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, country.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, country.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, country.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, country.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, country.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, country.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, country.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, country.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, country.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, country.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, country.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, country.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, country.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, country.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, country.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, country.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, country.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCountryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return country.And(predicates...), nil
	}
}

// RegionWhereInput represents a where input for filtering Region queries.
type RegionWhereInput struct {
	Predicates []predicate.Region  `json:"-"`
	Not        *RegionWhereInput   `json:"not,omitempty"`
	Or         []*RegionWhereInput `json:"or,omitempty"`
	And        []*RegionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "airports" edge predicates.
	HasAirports     *bool                `json:"hasAirports,omitempty"`
	HasAirportsWith []*AirportWhereInput `json:"hasAirportsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RegionWhereInput) AddPredicates(predicates ...predicate.Region) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RegionWhereInput filter on the RegionQuery builder.
func (i *RegionWhereInput) Filter(q *RegionQuery) (*RegionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRegionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRegionWhereInput is returned in case the RegionWhereInput is empty.
var ErrEmptyRegionWhereInput = errors.New("ent: empty predicate RegionWhereInput")

// P returns a predicate for filtering regions.
// An error is returned if the input is empty or invalid.
func (i *RegionWhereInput) P() (predicate.Region, error) {
	var predicates []predicate.Region
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, region.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Region, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, region.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Region, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, region.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, region.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, region.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, region.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, region.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, region.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, region.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, region.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, region.IDLTE(*i.IDLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, region.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, region.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, region.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, region.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, region.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, region.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, region.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, region.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, region.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, region.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, region.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, region.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, region.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, region.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, region.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, region.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, region.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, region.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, region.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, region.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, region.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, region.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, region.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, region.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, region.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, region.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasAirports != nil {
		p := region.HasAirports()
		if !*i.HasAirports {
			p = region.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAirportsWith) > 0 {
		with := make([]predicate.Airport, 0, len(i.HasAirportsWith))
		for _, w := range i.HasAirportsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAirportsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, region.HasAirportsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRegionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return region.And(predicates...), nil
	}
}

// StateWhereInput represents a where input for filtering State queries.
type StateWhereInput struct {
	Predicates []predicate.State  `json:"-"`
	Not        *StateWhereInput   `json:"not,omitempty"`
	Or         []*StateWhereInput `json:"or,omitempty"`
	And        []*StateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "cities" edge predicates.
	HasCities     *bool             `json:"hasCities,omitempty"`
	HasCitiesWith []*CityWhereInput `json:"hasCitiesWith,omitempty"`

	// "airports" edge predicates.
	HasAirports     *bool                `json:"hasAirports,omitempty"`
	HasAirportsWith []*AirportWhereInput `json:"hasAirportsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StateWhereInput) AddPredicates(predicates ...predicate.State) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StateWhereInput filter on the StateQuery builder.
func (i *StateWhereInput) Filter(q *StateQuery) (*StateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStateWhereInput is returned in case the StateWhereInput is empty.
var ErrEmptyStateWhereInput = errors.New("ent: empty predicate StateWhereInput")

// P returns a predicate for filtering states.
// An error is returned if the input is empty or invalid.
func (i *StateWhereInput) P() (predicate.State, error) {
	var predicates []predicate.State
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, state.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.State, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, state.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.State, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, state.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, state.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, state.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, state.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, state.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, state.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, state.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, state.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, state.IDLTE(*i.IDLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, state.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, state.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, state.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, state.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, state.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, state.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, state.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, state.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, state.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, state.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, state.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, state.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, state.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, state.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, state.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, state.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, state.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, state.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, state.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, state.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, state.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, state.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, state.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, state.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, state.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, state.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasCities != nil {
		p := state.HasCities()
		if !*i.HasCities {
			p = state.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCitiesWith) > 0 {
		with := make([]predicate.City, 0, len(i.HasCitiesWith))
		for _, w := range i.HasCitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, state.HasCitiesWith(with...))
	}
	if i.HasAirports != nil {
		p := state.HasAirports()
		if !*i.HasAirports {
			p = state.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAirportsWith) > 0 {
		with := make([]predicate.Airport, 0, len(i.HasAirportsWith))
		for _, w := range i.HasAirportsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAirportsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, state.HasAirportsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return state.And(predicates...), nil
	}
}
