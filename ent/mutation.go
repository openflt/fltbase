// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/openflt/fltbase/ent/airport"
	"github.com/openflt/fltbase/ent/city"
	"github.com/openflt/fltbase/ent/country"
	"github.com/openflt/fltbase/ent/predicate"
	"github.com/openflt/fltbase/ent/region"
	"github.com/openflt/fltbase/ent/state"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAirport = "Airport"
	TypeCity    = "City"
	TypeCountry = "Country"
	TypeRegion  = "Region"
	TypeState   = "State"
)

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	site_id                     *string
	facility_type               *airport.FacilityType
	airport_id                  *string
	ado_code                    *string
	name                        *string
	ownership_type              *airport.OwnershipType
	usage                       *airport.Usage
	latitude                    *float32
	addlatitude                 *float32
	longitude                   *float32
	addlongitude                *float32
	location_survey_method      *airport.LocationSurveyMethod
	elevation                   *float32
	addelevation                *float32
	elevation_survey_method     *airport.ElevationSurveyMethod
	magnetic_variance           *int8
	addmagnetic_variance        *int8
	magnetic_variance_year      *int8
	addmagnetic_variance_year   *int8
	traffic_pattern_altitude    *int8
	addtraffic_pattern_altitude *int8
	chart_name                  *string
	distance_to_city            *uint8
	adddistance_to_city         *int8
	direction_to_city           *airport.DirectionToCity
	acreage                     *uint8
	addacreage                  *int8
	artcc_id                    *string
	artcc_name                  *string
	computer_id                 *string
	fss_on_airport              *bool
	fss_id                      *string
	fss_name                    *string
	phone_number                *string
	toll_free_number            *string
	alternate_fss_id            *string
	alternate_fss_name          *string
	alternate_toll_free_number  *string
	notam_id                    *string
	notam_flag                  *bool
	activation_date             *time.Time
	status                      *airport.Status
	clearedFields               map[string]struct{}
	state                       *int
	clearedstate                bool
	city                        *int
	clearedcity                 bool
	region                      *int
	clearedregion               bool
	done                        bool
	oldValue                    func(context.Context) (*Airport, error)
	predicates                  []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id int) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSiteID sets the "site_id" field.
func (m *AirportMutation) SetSiteID(s string) {
	m.site_id = &s
}

// SiteID returns the value of the "site_id" field in the mutation.
func (m *AirportMutation) SiteID() (r string, exists bool) {
	v := m.site_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteID returns the old "site_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldSiteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteID: %w", err)
	}
	return oldValue.SiteID, nil
}

// ResetSiteID resets all changes to the "site_id" field.
func (m *AirportMutation) ResetSiteID() {
	m.site_id = nil
}

// SetFacilityType sets the "facility_type" field.
func (m *AirportMutation) SetFacilityType(at airport.FacilityType) {
	m.facility_type = &at
}

// FacilityType returns the value of the "facility_type" field in the mutation.
func (m *AirportMutation) FacilityType() (r airport.FacilityType, exists bool) {
	v := m.facility_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityType returns the old "facility_type" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldFacilityType(ctx context.Context) (v airport.FacilityType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacilityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacilityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityType: %w", err)
	}
	return oldValue.FacilityType, nil
}

// ResetFacilityType resets all changes to the "facility_type" field.
func (m *AirportMutation) ResetFacilityType() {
	m.facility_type = nil
}

// SetAirportID sets the "airport_id" field.
func (m *AirportMutation) SetAirportID(s string) {
	m.airport_id = &s
}

// AirportID returns the value of the "airport_id" field in the mutation.
func (m *AirportMutation) AirportID() (r string, exists bool) {
	v := m.airport_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAirportID returns the old "airport_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldAirportID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirportID: %w", err)
	}
	return oldValue.AirportID, nil
}

// ResetAirportID resets all changes to the "airport_id" field.
func (m *AirportMutation) ResetAirportID() {
	m.airport_id = nil
}

// SetAdoCode sets the "ado_code" field.
func (m *AirportMutation) SetAdoCode(s string) {
	m.ado_code = &s
}

// AdoCode returns the value of the "ado_code" field in the mutation.
func (m *AirportMutation) AdoCode() (r string, exists bool) {
	v := m.ado_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAdoCode returns the old "ado_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldAdoCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdoCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdoCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdoCode: %w", err)
	}
	return oldValue.AdoCode, nil
}

// ResetAdoCode resets all changes to the "ado_code" field.
func (m *AirportMutation) ResetAdoCode() {
	m.ado_code = nil
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetOwnershipType sets the "ownership_type" field.
func (m *AirportMutation) SetOwnershipType(at airport.OwnershipType) {
	m.ownership_type = &at
}

// OwnershipType returns the value of the "ownership_type" field in the mutation.
func (m *AirportMutation) OwnershipType() (r airport.OwnershipType, exists bool) {
	v := m.ownership_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnershipType returns the old "ownership_type" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldOwnershipType(ctx context.Context) (v airport.OwnershipType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnershipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnershipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnershipType: %w", err)
	}
	return oldValue.OwnershipType, nil
}

// ResetOwnershipType resets all changes to the "ownership_type" field.
func (m *AirportMutation) ResetOwnershipType() {
	m.ownership_type = nil
}

// SetUsage sets the "usage" field.
func (m *AirportMutation) SetUsage(a airport.Usage) {
	m.usage = &a
}

// Usage returns the value of the "usage" field in the mutation.
func (m *AirportMutation) Usage() (r airport.Usage, exists bool) {
	v := m.usage
	if v == nil {
		return
	}
	return *v, true
}

// OldUsage returns the old "usage" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldUsage(ctx context.Context) (v airport.Usage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsage: %w", err)
	}
	return oldValue.Usage, nil
}

// ResetUsage resets all changes to the "usage" field.
func (m *AirportMutation) ResetUsage() {
	m.usage = nil
}

// SetLatitude sets the "latitude" field.
func (m *AirportMutation) SetLatitude(f float32) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *AirportMutation) Latitude() (r float32, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLatitude(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *AirportMutation) AddLatitude(f float32) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *AirportMutation) AddedLatitude() (r float32, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *AirportMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *AirportMutation) SetLongitude(f float32) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *AirportMutation) Longitude() (r float32, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLongitude(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *AirportMutation) AddLongitude(f float32) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *AirportMutation) AddedLongitude() (r float32, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *AirportMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLocationSurveyMethod sets the "location_survey_method" field.
func (m *AirportMutation) SetLocationSurveyMethod(asm airport.LocationSurveyMethod) {
	m.location_survey_method = &asm
}

// LocationSurveyMethod returns the value of the "location_survey_method" field in the mutation.
func (m *AirportMutation) LocationSurveyMethod() (r airport.LocationSurveyMethod, exists bool) {
	v := m.location_survey_method
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationSurveyMethod returns the old "location_survey_method" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLocationSurveyMethod(ctx context.Context) (v airport.LocationSurveyMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationSurveyMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationSurveyMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationSurveyMethod: %w", err)
	}
	return oldValue.LocationSurveyMethod, nil
}

// ResetLocationSurveyMethod resets all changes to the "location_survey_method" field.
func (m *AirportMutation) ResetLocationSurveyMethod() {
	m.location_survey_method = nil
}

// SetElevation sets the "elevation" field.
func (m *AirportMutation) SetElevation(f float32) {
	m.elevation = &f
	m.addelevation = nil
}

// Elevation returns the value of the "elevation" field in the mutation.
func (m *AirportMutation) Elevation() (r float32, exists bool) {
	v := m.elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldElevation returns the old "elevation" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldElevation(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevation: %w", err)
	}
	return oldValue.Elevation, nil
}

// AddElevation adds f to the "elevation" field.
func (m *AirportMutation) AddElevation(f float32) {
	if m.addelevation != nil {
		*m.addelevation += f
	} else {
		m.addelevation = &f
	}
}

// AddedElevation returns the value that was added to the "elevation" field in this mutation.
func (m *AirportMutation) AddedElevation() (r float32, exists bool) {
	v := m.addelevation
	if v == nil {
		return
	}
	return *v, true
}

// ResetElevation resets all changes to the "elevation" field.
func (m *AirportMutation) ResetElevation() {
	m.elevation = nil
	m.addelevation = nil
}

// SetElevationSurveyMethod sets the "elevation_survey_method" field.
func (m *AirportMutation) SetElevationSurveyMethod(asm airport.ElevationSurveyMethod) {
	m.elevation_survey_method = &asm
}

// ElevationSurveyMethod returns the value of the "elevation_survey_method" field in the mutation.
func (m *AirportMutation) ElevationSurveyMethod() (r airport.ElevationSurveyMethod, exists bool) {
	v := m.elevation_survey_method
	if v == nil {
		return
	}
	return *v, true
}

// OldElevationSurveyMethod returns the old "elevation_survey_method" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldElevationSurveyMethod(ctx context.Context) (v airport.ElevationSurveyMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevationSurveyMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevationSurveyMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevationSurveyMethod: %w", err)
	}
	return oldValue.ElevationSurveyMethod, nil
}

// ResetElevationSurveyMethod resets all changes to the "elevation_survey_method" field.
func (m *AirportMutation) ResetElevationSurveyMethod() {
	m.elevation_survey_method = nil
}

// SetMagneticVariance sets the "magnetic_variance" field.
func (m *AirportMutation) SetMagneticVariance(i int8) {
	m.magnetic_variance = &i
	m.addmagnetic_variance = nil
}

// MagneticVariance returns the value of the "magnetic_variance" field in the mutation.
func (m *AirportMutation) MagneticVariance() (r int8, exists bool) {
	v := m.magnetic_variance
	if v == nil {
		return
	}
	return *v, true
}

// OldMagneticVariance returns the old "magnetic_variance" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldMagneticVariance(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagneticVariance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagneticVariance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagneticVariance: %w", err)
	}
	return oldValue.MagneticVariance, nil
}

// AddMagneticVariance adds i to the "magnetic_variance" field.
func (m *AirportMutation) AddMagneticVariance(i int8) {
	if m.addmagnetic_variance != nil {
		*m.addmagnetic_variance += i
	} else {
		m.addmagnetic_variance = &i
	}
}

// AddedMagneticVariance returns the value that was added to the "magnetic_variance" field in this mutation.
func (m *AirportMutation) AddedMagneticVariance() (r int8, exists bool) {
	v := m.addmagnetic_variance
	if v == nil {
		return
	}
	return *v, true
}

// ResetMagneticVariance resets all changes to the "magnetic_variance" field.
func (m *AirportMutation) ResetMagneticVariance() {
	m.magnetic_variance = nil
	m.addmagnetic_variance = nil
}

// SetMagneticVarianceYear sets the "magnetic_variance_year" field.
func (m *AirportMutation) SetMagneticVarianceYear(i int8) {
	m.magnetic_variance_year = &i
	m.addmagnetic_variance_year = nil
}

// MagneticVarianceYear returns the value of the "magnetic_variance_year" field in the mutation.
func (m *AirportMutation) MagneticVarianceYear() (r int8, exists bool) {
	v := m.magnetic_variance_year
	if v == nil {
		return
	}
	return *v, true
}

// OldMagneticVarianceYear returns the old "magnetic_variance_year" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldMagneticVarianceYear(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagneticVarianceYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagneticVarianceYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagneticVarianceYear: %w", err)
	}
	return oldValue.MagneticVarianceYear, nil
}

// AddMagneticVarianceYear adds i to the "magnetic_variance_year" field.
func (m *AirportMutation) AddMagneticVarianceYear(i int8) {
	if m.addmagnetic_variance_year != nil {
		*m.addmagnetic_variance_year += i
	} else {
		m.addmagnetic_variance_year = &i
	}
}

// AddedMagneticVarianceYear returns the value that was added to the "magnetic_variance_year" field in this mutation.
func (m *AirportMutation) AddedMagneticVarianceYear() (r int8, exists bool) {
	v := m.addmagnetic_variance_year
	if v == nil {
		return
	}
	return *v, true
}

// ResetMagneticVarianceYear resets all changes to the "magnetic_variance_year" field.
func (m *AirportMutation) ResetMagneticVarianceYear() {
	m.magnetic_variance_year = nil
	m.addmagnetic_variance_year = nil
}

// SetTrafficPatternAltitude sets the "traffic_pattern_altitude" field.
func (m *AirportMutation) SetTrafficPatternAltitude(i int8) {
	m.traffic_pattern_altitude = &i
	m.addtraffic_pattern_altitude = nil
}

// TrafficPatternAltitude returns the value of the "traffic_pattern_altitude" field in the mutation.
func (m *AirportMutation) TrafficPatternAltitude() (r int8, exists bool) {
	v := m.traffic_pattern_altitude
	if v == nil {
		return
	}
	return *v, true
}

// OldTrafficPatternAltitude returns the old "traffic_pattern_altitude" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldTrafficPatternAltitude(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrafficPatternAltitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrafficPatternAltitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrafficPatternAltitude: %w", err)
	}
	return oldValue.TrafficPatternAltitude, nil
}

// AddTrafficPatternAltitude adds i to the "traffic_pattern_altitude" field.
func (m *AirportMutation) AddTrafficPatternAltitude(i int8) {
	if m.addtraffic_pattern_altitude != nil {
		*m.addtraffic_pattern_altitude += i
	} else {
		m.addtraffic_pattern_altitude = &i
	}
}

// AddedTrafficPatternAltitude returns the value that was added to the "traffic_pattern_altitude" field in this mutation.
func (m *AirportMutation) AddedTrafficPatternAltitude() (r int8, exists bool) {
	v := m.addtraffic_pattern_altitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetTrafficPatternAltitude resets all changes to the "traffic_pattern_altitude" field.
func (m *AirportMutation) ResetTrafficPatternAltitude() {
	m.traffic_pattern_altitude = nil
	m.addtraffic_pattern_altitude = nil
}

// SetChartName sets the "chart_name" field.
func (m *AirportMutation) SetChartName(s string) {
	m.chart_name = &s
}

// ChartName returns the value of the "chart_name" field in the mutation.
func (m *AirportMutation) ChartName() (r string, exists bool) {
	v := m.chart_name
	if v == nil {
		return
	}
	return *v, true
}

// OldChartName returns the old "chart_name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldChartName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChartName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChartName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChartName: %w", err)
	}
	return oldValue.ChartName, nil
}

// ResetChartName resets all changes to the "chart_name" field.
func (m *AirportMutation) ResetChartName() {
	m.chart_name = nil
}

// SetDistanceToCity sets the "distance_to_city" field.
func (m *AirportMutation) SetDistanceToCity(u uint8) {
	m.distance_to_city = &u
	m.adddistance_to_city = nil
}

// DistanceToCity returns the value of the "distance_to_city" field in the mutation.
func (m *AirportMutation) DistanceToCity() (r uint8, exists bool) {
	v := m.distance_to_city
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceToCity returns the old "distance_to_city" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldDistanceToCity(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceToCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceToCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceToCity: %w", err)
	}
	return oldValue.DistanceToCity, nil
}

// AddDistanceToCity adds u to the "distance_to_city" field.
func (m *AirportMutation) AddDistanceToCity(u int8) {
	if m.adddistance_to_city != nil {
		*m.adddistance_to_city += u
	} else {
		m.adddistance_to_city = &u
	}
}

// AddedDistanceToCity returns the value that was added to the "distance_to_city" field in this mutation.
func (m *AirportMutation) AddedDistanceToCity() (r int8, exists bool) {
	v := m.adddistance_to_city
	if v == nil {
		return
	}
	return *v, true
}

// ResetDistanceToCity resets all changes to the "distance_to_city" field.
func (m *AirportMutation) ResetDistanceToCity() {
	m.distance_to_city = nil
	m.adddistance_to_city = nil
}

// SetDirectionToCity sets the "direction_to_city" field.
func (m *AirportMutation) SetDirectionToCity(atc airport.DirectionToCity) {
	m.direction_to_city = &atc
}

// DirectionToCity returns the value of the "direction_to_city" field in the mutation.
func (m *AirportMutation) DirectionToCity() (r airport.DirectionToCity, exists bool) {
	v := m.direction_to_city
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectionToCity returns the old "direction_to_city" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldDirectionToCity(ctx context.Context) (v airport.DirectionToCity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectionToCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectionToCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectionToCity: %w", err)
	}
	return oldValue.DirectionToCity, nil
}

// ResetDirectionToCity resets all changes to the "direction_to_city" field.
func (m *AirportMutation) ResetDirectionToCity() {
	m.direction_to_city = nil
}

// SetAcreage sets the "acreage" field.
func (m *AirportMutation) SetAcreage(u uint8) {
	m.acreage = &u
	m.addacreage = nil
}

// Acreage returns the value of the "acreage" field in the mutation.
func (m *AirportMutation) Acreage() (r uint8, exists bool) {
	v := m.acreage
	if v == nil {
		return
	}
	return *v, true
}

// OldAcreage returns the old "acreage" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldAcreage(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcreage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcreage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcreage: %w", err)
	}
	return oldValue.Acreage, nil
}

// AddAcreage adds u to the "acreage" field.
func (m *AirportMutation) AddAcreage(u int8) {
	if m.addacreage != nil {
		*m.addacreage += u
	} else {
		m.addacreage = &u
	}
}

// AddedAcreage returns the value that was added to the "acreage" field in this mutation.
func (m *AirportMutation) AddedAcreage() (r int8, exists bool) {
	v := m.addacreage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAcreage resets all changes to the "acreage" field.
func (m *AirportMutation) ResetAcreage() {
	m.acreage = nil
	m.addacreage = nil
}

// SetArtccID sets the "artcc_id" field.
func (m *AirportMutation) SetArtccID(s string) {
	m.artcc_id = &s
}

// ArtccID returns the value of the "artcc_id" field in the mutation.
func (m *AirportMutation) ArtccID() (r string, exists bool) {
	v := m.artcc_id
	if v == nil {
		return
	}
	return *v, true
}

// OldArtccID returns the old "artcc_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldArtccID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtccID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtccID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtccID: %w", err)
	}
	return oldValue.ArtccID, nil
}

// ResetArtccID resets all changes to the "artcc_id" field.
func (m *AirportMutation) ResetArtccID() {
	m.artcc_id = nil
}

// SetArtccName sets the "artcc_name" field.
func (m *AirportMutation) SetArtccName(s string) {
	m.artcc_name = &s
}

// ArtccName returns the value of the "artcc_name" field in the mutation.
func (m *AirportMutation) ArtccName() (r string, exists bool) {
	v := m.artcc_name
	if v == nil {
		return
	}
	return *v, true
}

// OldArtccName returns the old "artcc_name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldArtccName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtccName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtccName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtccName: %w", err)
	}
	return oldValue.ArtccName, nil
}

// ResetArtccName resets all changes to the "artcc_name" field.
func (m *AirportMutation) ResetArtccName() {
	m.artcc_name = nil
}

// SetComputerID sets the "computer_id" field.
func (m *AirportMutation) SetComputerID(s string) {
	m.computer_id = &s
}

// ComputerID returns the value of the "computer_id" field in the mutation.
func (m *AirportMutation) ComputerID() (r string, exists bool) {
	v := m.computer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldComputerID returns the old "computer_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldComputerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComputerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComputerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComputerID: %w", err)
	}
	return oldValue.ComputerID, nil
}

// ResetComputerID resets all changes to the "computer_id" field.
func (m *AirportMutation) ResetComputerID() {
	m.computer_id = nil
}

// SetFssOnAirport sets the "fss_on_airport" field.
func (m *AirportMutation) SetFssOnAirport(b bool) {
	m.fss_on_airport = &b
}

// FssOnAirport returns the value of the "fss_on_airport" field in the mutation.
func (m *AirportMutation) FssOnAirport() (r bool, exists bool) {
	v := m.fss_on_airport
	if v == nil {
		return
	}
	return *v, true
}

// OldFssOnAirport returns the old "fss_on_airport" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldFssOnAirport(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFssOnAirport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFssOnAirport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFssOnAirport: %w", err)
	}
	return oldValue.FssOnAirport, nil
}

// ResetFssOnAirport resets all changes to the "fss_on_airport" field.
func (m *AirportMutation) ResetFssOnAirport() {
	m.fss_on_airport = nil
}

// SetFssID sets the "fss_id" field.
func (m *AirportMutation) SetFssID(s string) {
	m.fss_id = &s
}

// FssID returns the value of the "fss_id" field in the mutation.
func (m *AirportMutation) FssID() (r string, exists bool) {
	v := m.fss_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFssID returns the old "fss_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldFssID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFssID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFssID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFssID: %w", err)
	}
	return oldValue.FssID, nil
}

// ResetFssID resets all changes to the "fss_id" field.
func (m *AirportMutation) ResetFssID() {
	m.fss_id = nil
}

// SetFssName sets the "fss_name" field.
func (m *AirportMutation) SetFssName(s string) {
	m.fss_name = &s
}

// FssName returns the value of the "fss_name" field in the mutation.
func (m *AirportMutation) FssName() (r string, exists bool) {
	v := m.fss_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFssName returns the old "fss_name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldFssName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFssName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFssName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFssName: %w", err)
	}
	return oldValue.FssName, nil
}

// ResetFssName resets all changes to the "fss_name" field.
func (m *AirportMutation) ResetFssName() {
	m.fss_name = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AirportMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AirportMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AirportMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetTollFreeNumber sets the "toll_free_number" field.
func (m *AirportMutation) SetTollFreeNumber(s string) {
	m.toll_free_number = &s
}

// TollFreeNumber returns the value of the "toll_free_number" field in the mutation.
func (m *AirportMutation) TollFreeNumber() (r string, exists bool) {
	v := m.toll_free_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTollFreeNumber returns the old "toll_free_number" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldTollFreeNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTollFreeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTollFreeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTollFreeNumber: %w", err)
	}
	return oldValue.TollFreeNumber, nil
}

// ResetTollFreeNumber resets all changes to the "toll_free_number" field.
func (m *AirportMutation) ResetTollFreeNumber() {
	m.toll_free_number = nil
}

// SetAlternateFssID sets the "alternate_fss_id" field.
func (m *AirportMutation) SetAlternateFssID(s string) {
	m.alternate_fss_id = &s
}

// AlternateFssID returns the value of the "alternate_fss_id" field in the mutation.
func (m *AirportMutation) AlternateFssID() (r string, exists bool) {
	v := m.alternate_fss_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternateFssID returns the old "alternate_fss_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldAlternateFssID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternateFssID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternateFssID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternateFssID: %w", err)
	}
	return oldValue.AlternateFssID, nil
}

// ResetAlternateFssID resets all changes to the "alternate_fss_id" field.
func (m *AirportMutation) ResetAlternateFssID() {
	m.alternate_fss_id = nil
}

// SetAlternateFssName sets the "alternate_fss_name" field.
func (m *AirportMutation) SetAlternateFssName(s string) {
	m.alternate_fss_name = &s
}

// AlternateFssName returns the value of the "alternate_fss_name" field in the mutation.
func (m *AirportMutation) AlternateFssName() (r string, exists bool) {
	v := m.alternate_fss_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternateFssName returns the old "alternate_fss_name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldAlternateFssName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternateFssName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternateFssName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternateFssName: %w", err)
	}
	return oldValue.AlternateFssName, nil
}

// ResetAlternateFssName resets all changes to the "alternate_fss_name" field.
func (m *AirportMutation) ResetAlternateFssName() {
	m.alternate_fss_name = nil
}

// SetAlternateTollFreeNumber sets the "alternate_toll_free_number" field.
func (m *AirportMutation) SetAlternateTollFreeNumber(s string) {
	m.alternate_toll_free_number = &s
}

// AlternateTollFreeNumber returns the value of the "alternate_toll_free_number" field in the mutation.
func (m *AirportMutation) AlternateTollFreeNumber() (r string, exists bool) {
	v := m.alternate_toll_free_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternateTollFreeNumber returns the old "alternate_toll_free_number" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldAlternateTollFreeNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternateTollFreeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternateTollFreeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternateTollFreeNumber: %w", err)
	}
	return oldValue.AlternateTollFreeNumber, nil
}

// ResetAlternateTollFreeNumber resets all changes to the "alternate_toll_free_number" field.
func (m *AirportMutation) ResetAlternateTollFreeNumber() {
	m.alternate_toll_free_number = nil
}

// SetNotamID sets the "notam_id" field.
func (m *AirportMutation) SetNotamID(s string) {
	m.notam_id = &s
}

// NotamID returns the value of the "notam_id" field in the mutation.
func (m *AirportMutation) NotamID() (r string, exists bool) {
	v := m.notam_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNotamID returns the old "notam_id" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldNotamID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotamID: %w", err)
	}
	return oldValue.NotamID, nil
}

// ResetNotamID resets all changes to the "notam_id" field.
func (m *AirportMutation) ResetNotamID() {
	m.notam_id = nil
}

// SetNotamFlag sets the "notam_flag" field.
func (m *AirportMutation) SetNotamFlag(b bool) {
	m.notam_flag = &b
}

// NotamFlag returns the value of the "notam_flag" field in the mutation.
func (m *AirportMutation) NotamFlag() (r bool, exists bool) {
	v := m.notam_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldNotamFlag returns the old "notam_flag" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldNotamFlag(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotamFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotamFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotamFlag: %w", err)
	}
	return oldValue.NotamFlag, nil
}

// ResetNotamFlag resets all changes to the "notam_flag" field.
func (m *AirportMutation) ResetNotamFlag() {
	m.notam_flag = nil
}

// SetActivationDate sets the "activation_date" field.
func (m *AirportMutation) SetActivationDate(t time.Time) {
	m.activation_date = &t
}

// ActivationDate returns the value of the "activation_date" field in the mutation.
func (m *AirportMutation) ActivationDate() (r time.Time, exists bool) {
	v := m.activation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActivationDate returns the old "activation_date" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldActivationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivationDate: %w", err)
	}
	return oldValue.ActivationDate, nil
}

// ResetActivationDate resets all changes to the "activation_date" field.
func (m *AirportMutation) ResetActivationDate() {
	m.activation_date = nil
}

// SetStatus sets the "status" field.
func (m *AirportMutation) SetStatus(a airport.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AirportMutation) Status() (r airport.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldStatus(ctx context.Context) (v airport.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AirportMutation) ResetStatus() {
	m.status = nil
}

// SetStateID sets the "state" edge to the State entity by id.
func (m *AirportMutation) SetStateID(id int) {
	m.state = &id
}

// ClearState clears the "state" edge to the State entity.
func (m *AirportMutation) ClearState() {
	m.clearedstate = true
}

// StateCleared reports if the "state" edge to the State entity was cleared.
func (m *AirportMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the "state" edge ID in the mutation.
func (m *AirportMutation) StateID() (id int, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) StateIDs() (ids []int) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *AirportMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// SetCityID sets the "city" edge to the City entity by id.
func (m *AirportMutation) SetCityID(id int) {
	m.city = &id
}

// ClearCity clears the "city" edge to the City entity.
func (m *AirportMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *AirportMutation) CityCleared() bool {
	return m.clearedcity
}

// CityID returns the "city" edge ID in the mutation.
func (m *AirportMutation) CityID() (id int, exists bool) {
	if m.city != nil {
		return *m.city, true
	}
	return
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) CityIDs() (ids []int) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *AirportMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetRegionID sets the "region" edge to the Region entity by id.
func (m *AirportMutation) SetRegionID(id int) {
	m.region = &id
}

// ClearRegion clears the "region" edge to the Region entity.
func (m *AirportMutation) ClearRegion() {
	m.clearedregion = true
}

// RegionCleared reports if the "region" edge to the Region entity was cleared.
func (m *AirportMutation) RegionCleared() bool {
	return m.clearedregion
}

// RegionID returns the "region" edge ID in the mutation.
func (m *AirportMutation) RegionID() (id int, exists bool) {
	if m.region != nil {
		return *m.region, true
	}
	return
}

// RegionIDs returns the "region" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegionID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) RegionIDs() (ids []int) {
	if id := m.region; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegion resets all changes to the "region" edge.
func (m *AirportMutation) ResetRegion() {
	m.region = nil
	m.clearedregion = false
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AirportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AirportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Airport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AirportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.site_id != nil {
		fields = append(fields, airport.FieldSiteID)
	}
	if m.facility_type != nil {
		fields = append(fields, airport.FieldFacilityType)
	}
	if m.airport_id != nil {
		fields = append(fields, airport.FieldAirportID)
	}
	if m.ado_code != nil {
		fields = append(fields, airport.FieldAdoCode)
	}
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.ownership_type != nil {
		fields = append(fields, airport.FieldOwnershipType)
	}
	if m.usage != nil {
		fields = append(fields, airport.FieldUsage)
	}
	if m.latitude != nil {
		fields = append(fields, airport.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, airport.FieldLongitude)
	}
	if m.location_survey_method != nil {
		fields = append(fields, airport.FieldLocationSurveyMethod)
	}
	if m.elevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	if m.elevation_survey_method != nil {
		fields = append(fields, airport.FieldElevationSurveyMethod)
	}
	if m.magnetic_variance != nil {
		fields = append(fields, airport.FieldMagneticVariance)
	}
	if m.magnetic_variance_year != nil {
		fields = append(fields, airport.FieldMagneticVarianceYear)
	}
	if m.traffic_pattern_altitude != nil {
		fields = append(fields, airport.FieldTrafficPatternAltitude)
	}
	if m.chart_name != nil {
		fields = append(fields, airport.FieldChartName)
	}
	if m.distance_to_city != nil {
		fields = append(fields, airport.FieldDistanceToCity)
	}
	if m.direction_to_city != nil {
		fields = append(fields, airport.FieldDirectionToCity)
	}
	if m.acreage != nil {
		fields = append(fields, airport.FieldAcreage)
	}
	if m.artcc_id != nil {
		fields = append(fields, airport.FieldArtccID)
	}
	if m.artcc_name != nil {
		fields = append(fields, airport.FieldArtccName)
	}
	if m.computer_id != nil {
		fields = append(fields, airport.FieldComputerID)
	}
	if m.fss_on_airport != nil {
		fields = append(fields, airport.FieldFssOnAirport)
	}
	if m.fss_id != nil {
		fields = append(fields, airport.FieldFssID)
	}
	if m.fss_name != nil {
		fields = append(fields, airport.FieldFssName)
	}
	if m.phone_number != nil {
		fields = append(fields, airport.FieldPhoneNumber)
	}
	if m.toll_free_number != nil {
		fields = append(fields, airport.FieldTollFreeNumber)
	}
	if m.alternate_fss_id != nil {
		fields = append(fields, airport.FieldAlternateFssID)
	}
	if m.alternate_fss_name != nil {
		fields = append(fields, airport.FieldAlternateFssName)
	}
	if m.alternate_toll_free_number != nil {
		fields = append(fields, airport.FieldAlternateTollFreeNumber)
	}
	if m.notam_id != nil {
		fields = append(fields, airport.FieldNotamID)
	}
	if m.notam_flag != nil {
		fields = append(fields, airport.FieldNotamFlag)
	}
	if m.activation_date != nil {
		fields = append(fields, airport.FieldActivationDate)
	}
	if m.status != nil {
		fields = append(fields, airport.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldSiteID:
		return m.SiteID()
	case airport.FieldFacilityType:
		return m.FacilityType()
	case airport.FieldAirportID:
		return m.AirportID()
	case airport.FieldAdoCode:
		return m.AdoCode()
	case airport.FieldName:
		return m.Name()
	case airport.FieldOwnershipType:
		return m.OwnershipType()
	case airport.FieldUsage:
		return m.Usage()
	case airport.FieldLatitude:
		return m.Latitude()
	case airport.FieldLongitude:
		return m.Longitude()
	case airport.FieldLocationSurveyMethod:
		return m.LocationSurveyMethod()
	case airport.FieldElevation:
		return m.Elevation()
	case airport.FieldElevationSurveyMethod:
		return m.ElevationSurveyMethod()
	case airport.FieldMagneticVariance:
		return m.MagneticVariance()
	case airport.FieldMagneticVarianceYear:
		return m.MagneticVarianceYear()
	case airport.FieldTrafficPatternAltitude:
		return m.TrafficPatternAltitude()
	case airport.FieldChartName:
		return m.ChartName()
	case airport.FieldDistanceToCity:
		return m.DistanceToCity()
	case airport.FieldDirectionToCity:
		return m.DirectionToCity()
	case airport.FieldAcreage:
		return m.Acreage()
	case airport.FieldArtccID:
		return m.ArtccID()
	case airport.FieldArtccName:
		return m.ArtccName()
	case airport.FieldComputerID:
		return m.ComputerID()
	case airport.FieldFssOnAirport:
		return m.FssOnAirport()
	case airport.FieldFssID:
		return m.FssID()
	case airport.FieldFssName:
		return m.FssName()
	case airport.FieldPhoneNumber:
		return m.PhoneNumber()
	case airport.FieldTollFreeNumber:
		return m.TollFreeNumber()
	case airport.FieldAlternateFssID:
		return m.AlternateFssID()
	case airport.FieldAlternateFssName:
		return m.AlternateFssName()
	case airport.FieldAlternateTollFreeNumber:
		return m.AlternateTollFreeNumber()
	case airport.FieldNotamID:
		return m.NotamID()
	case airport.FieldNotamFlag:
		return m.NotamFlag()
	case airport.FieldActivationDate:
		return m.ActivationDate()
	case airport.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldSiteID:
		return m.OldSiteID(ctx)
	case airport.FieldFacilityType:
		return m.OldFacilityType(ctx)
	case airport.FieldAirportID:
		return m.OldAirportID(ctx)
	case airport.FieldAdoCode:
		return m.OldAdoCode(ctx)
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldOwnershipType:
		return m.OldOwnershipType(ctx)
	case airport.FieldUsage:
		return m.OldUsage(ctx)
	case airport.FieldLatitude:
		return m.OldLatitude(ctx)
	case airport.FieldLongitude:
		return m.OldLongitude(ctx)
	case airport.FieldLocationSurveyMethod:
		return m.OldLocationSurveyMethod(ctx)
	case airport.FieldElevation:
		return m.OldElevation(ctx)
	case airport.FieldElevationSurveyMethod:
		return m.OldElevationSurveyMethod(ctx)
	case airport.FieldMagneticVariance:
		return m.OldMagneticVariance(ctx)
	case airport.FieldMagneticVarianceYear:
		return m.OldMagneticVarianceYear(ctx)
	case airport.FieldTrafficPatternAltitude:
		return m.OldTrafficPatternAltitude(ctx)
	case airport.FieldChartName:
		return m.OldChartName(ctx)
	case airport.FieldDistanceToCity:
		return m.OldDistanceToCity(ctx)
	case airport.FieldDirectionToCity:
		return m.OldDirectionToCity(ctx)
	case airport.FieldAcreage:
		return m.OldAcreage(ctx)
	case airport.FieldArtccID:
		return m.OldArtccID(ctx)
	case airport.FieldArtccName:
		return m.OldArtccName(ctx)
	case airport.FieldComputerID:
		return m.OldComputerID(ctx)
	case airport.FieldFssOnAirport:
		return m.OldFssOnAirport(ctx)
	case airport.FieldFssID:
		return m.OldFssID(ctx)
	case airport.FieldFssName:
		return m.OldFssName(ctx)
	case airport.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case airport.FieldTollFreeNumber:
		return m.OldTollFreeNumber(ctx)
	case airport.FieldAlternateFssID:
		return m.OldAlternateFssID(ctx)
	case airport.FieldAlternateFssName:
		return m.OldAlternateFssName(ctx)
	case airport.FieldAlternateTollFreeNumber:
		return m.OldAlternateTollFreeNumber(ctx)
	case airport.FieldNotamID:
		return m.OldNotamID(ctx)
	case airport.FieldNotamFlag:
		return m.OldNotamFlag(ctx)
	case airport.FieldActivationDate:
		return m.OldActivationDate(ctx)
	case airport.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldSiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteID(v)
		return nil
	case airport.FieldFacilityType:
		v, ok := value.(airport.FacilityType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityType(v)
		return nil
	case airport.FieldAirportID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirportID(v)
		return nil
	case airport.FieldAdoCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdoCode(v)
		return nil
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldOwnershipType:
		v, ok := value.(airport.OwnershipType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnershipType(v)
		return nil
	case airport.FieldUsage:
		v, ok := value.(airport.Usage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsage(v)
		return nil
	case airport.FieldLatitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case airport.FieldLongitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case airport.FieldLocationSurveyMethod:
		v, ok := value.(airport.LocationSurveyMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationSurveyMethod(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevation(v)
		return nil
	case airport.FieldElevationSurveyMethod:
		v, ok := value.(airport.ElevationSurveyMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevationSurveyMethod(v)
		return nil
	case airport.FieldMagneticVariance:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagneticVariance(v)
		return nil
	case airport.FieldMagneticVarianceYear:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagneticVarianceYear(v)
		return nil
	case airport.FieldTrafficPatternAltitude:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrafficPatternAltitude(v)
		return nil
	case airport.FieldChartName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChartName(v)
		return nil
	case airport.FieldDistanceToCity:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceToCity(v)
		return nil
	case airport.FieldDirectionToCity:
		v, ok := value.(airport.DirectionToCity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectionToCity(v)
		return nil
	case airport.FieldAcreage:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcreage(v)
		return nil
	case airport.FieldArtccID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtccID(v)
		return nil
	case airport.FieldArtccName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtccName(v)
		return nil
	case airport.FieldComputerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComputerID(v)
		return nil
	case airport.FieldFssOnAirport:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFssOnAirport(v)
		return nil
	case airport.FieldFssID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFssID(v)
		return nil
	case airport.FieldFssName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFssName(v)
		return nil
	case airport.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case airport.FieldTollFreeNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTollFreeNumber(v)
		return nil
	case airport.FieldAlternateFssID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternateFssID(v)
		return nil
	case airport.FieldAlternateFssName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternateFssName(v)
		return nil
	case airport.FieldAlternateTollFreeNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternateTollFreeNumber(v)
		return nil
	case airport.FieldNotamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotamID(v)
		return nil
	case airport.FieldNotamFlag:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotamFlag(v)
		return nil
	case airport.FieldActivationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivationDate(v)
		return nil
	case airport.FieldStatus:
		v, ok := value.(airport.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, airport.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, airport.FieldLongitude)
	}
	if m.addelevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	if m.addmagnetic_variance != nil {
		fields = append(fields, airport.FieldMagneticVariance)
	}
	if m.addmagnetic_variance_year != nil {
		fields = append(fields, airport.FieldMagneticVarianceYear)
	}
	if m.addtraffic_pattern_altitude != nil {
		fields = append(fields, airport.FieldTrafficPatternAltitude)
	}
	if m.adddistance_to_city != nil {
		fields = append(fields, airport.FieldDistanceToCity)
	}
	if m.addacreage != nil {
		fields = append(fields, airport.FieldAcreage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldLatitude:
		return m.AddedLatitude()
	case airport.FieldLongitude:
		return m.AddedLongitude()
	case airport.FieldElevation:
		return m.AddedElevation()
	case airport.FieldMagneticVariance:
		return m.AddedMagneticVariance()
	case airport.FieldMagneticVarianceYear:
		return m.AddedMagneticVarianceYear()
	case airport.FieldTrafficPatternAltitude:
		return m.AddedTrafficPatternAltitude()
	case airport.FieldDistanceToCity:
		return m.AddedDistanceToCity()
	case airport.FieldAcreage:
		return m.AddedAcreage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case airport.FieldLatitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case airport.FieldLongitude:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElevation(v)
		return nil
	case airport.FieldMagneticVariance:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMagneticVariance(v)
		return nil
	case airport.FieldMagneticVarianceYear:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMagneticVarianceYear(v)
		return nil
	case airport.FieldTrafficPatternAltitude:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTrafficPatternAltitude(v)
		return nil
	case airport.FieldDistanceToCity:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistanceToCity(v)
		return nil
	case airport.FieldAcreage:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcreage(v)
		return nil
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldSiteID:
		m.ResetSiteID()
		return nil
	case airport.FieldFacilityType:
		m.ResetFacilityType()
		return nil
	case airport.FieldAirportID:
		m.ResetAirportID()
		return nil
	case airport.FieldAdoCode:
		m.ResetAdoCode()
		return nil
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldOwnershipType:
		m.ResetOwnershipType()
		return nil
	case airport.FieldUsage:
		m.ResetUsage()
		return nil
	case airport.FieldLatitude:
		m.ResetLatitude()
		return nil
	case airport.FieldLongitude:
		m.ResetLongitude()
		return nil
	case airport.FieldLocationSurveyMethod:
		m.ResetLocationSurveyMethod()
		return nil
	case airport.FieldElevation:
		m.ResetElevation()
		return nil
	case airport.FieldElevationSurveyMethod:
		m.ResetElevationSurveyMethod()
		return nil
	case airport.FieldMagneticVariance:
		m.ResetMagneticVariance()
		return nil
	case airport.FieldMagneticVarianceYear:
		m.ResetMagneticVarianceYear()
		return nil
	case airport.FieldTrafficPatternAltitude:
		m.ResetTrafficPatternAltitude()
		return nil
	case airport.FieldChartName:
		m.ResetChartName()
		return nil
	case airport.FieldDistanceToCity:
		m.ResetDistanceToCity()
		return nil
	case airport.FieldDirectionToCity:
		m.ResetDirectionToCity()
		return nil
	case airport.FieldAcreage:
		m.ResetAcreage()
		return nil
	case airport.FieldArtccID:
		m.ResetArtccID()
		return nil
	case airport.FieldArtccName:
		m.ResetArtccName()
		return nil
	case airport.FieldComputerID:
		m.ResetComputerID()
		return nil
	case airport.FieldFssOnAirport:
		m.ResetFssOnAirport()
		return nil
	case airport.FieldFssID:
		m.ResetFssID()
		return nil
	case airport.FieldFssName:
		m.ResetFssName()
		return nil
	case airport.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case airport.FieldTollFreeNumber:
		m.ResetTollFreeNumber()
		return nil
	case airport.FieldAlternateFssID:
		m.ResetAlternateFssID()
		return nil
	case airport.FieldAlternateFssName:
		m.ResetAlternateFssName()
		return nil
	case airport.FieldAlternateTollFreeNumber:
		m.ResetAlternateTollFreeNumber()
		return nil
	case airport.FieldNotamID:
		m.ResetNotamID()
		return nil
	case airport.FieldNotamFlag:
		m.ResetNotamFlag()
		return nil
	case airport.FieldActivationDate:
		m.ResetActivationDate()
		return nil
	case airport.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.state != nil {
		edges = append(edges, airport.EdgeState)
	}
	if m.city != nil {
		edges = append(edges, airport.EdgeCity)
	}
	if m.region != nil {
		edges = append(edges, airport.EdgeRegion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case airport.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case airport.EdgeRegion:
		if id := m.region; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstate {
		edges = append(edges, airport.EdgeState)
	}
	if m.clearedcity {
		edges = append(edges, airport.EdgeCity)
	}
	if m.clearedregion {
		edges = append(edges, airport.EdgeRegion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeState:
		return m.clearedstate
	case airport.EdgeCity:
		return m.clearedcity
	case airport.EdgeRegion:
		return m.clearedregion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	case airport.EdgeState:
		m.ClearState()
		return nil
	case airport.EdgeCity:
		m.ClearCity()
		return nil
	case airport.EdgeRegion:
		m.ClearRegion()
		return nil
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeState:
		m.ResetState()
		return nil
	case airport.EdgeCity:
		m.ResetCity()
		return nil
	case airport.EdgeRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	clearedFields   map[string]struct{}
	state           *int
	clearedstate    bool
	airports        map[int]struct{}
	removedairports map[int]struct{}
	clearedairports bool
	done            bool
	oldValue        func(context.Context) (*City, error)
	predicates      []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id int) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetStateID sets the "state" edge to the State entity by id.
func (m *CityMutation) SetStateID(id int) {
	m.state = &id
}

// ClearState clears the "state" edge to the State entity.
func (m *CityMutation) ClearState() {
	m.clearedstate = true
}

// StateCleared reports if the "state" edge to the State entity was cleared.
func (m *CityMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the "state" edge ID in the mutation.
func (m *CityMutation) StateID() (id int, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *CityMutation) StateIDs() (ids []int) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *CityMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// AddAirportIDs adds the "airports" edge to the Airport entity by ids.
func (m *CityMutation) AddAirportIDs(ids ...int) {
	if m.airports == nil {
		m.airports = make(map[int]struct{})
	}
	for i := range ids {
		m.airports[ids[i]] = struct{}{}
	}
}

// ClearAirports clears the "airports" edge to the Airport entity.
func (m *CityMutation) ClearAirports() {
	m.clearedairports = true
}

// AirportsCleared reports if the "airports" edge to the Airport entity was cleared.
func (m *CityMutation) AirportsCleared() bool {
	return m.clearedairports
}

// RemoveAirportIDs removes the "airports" edge to the Airport entity by IDs.
func (m *CityMutation) RemoveAirportIDs(ids ...int) {
	if m.removedairports == nil {
		m.removedairports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.airports, ids[i])
		m.removedairports[ids[i]] = struct{}{}
	}
}

// RemovedAirports returns the removed IDs of the "airports" edge to the Airport entity.
func (m *CityMutation) RemovedAirportsIDs() (ids []int) {
	for id := range m.removedairports {
		ids = append(ids, id)
	}
	return
}

// AirportsIDs returns the "airports" edge IDs in the mutation.
func (m *CityMutation) AirportsIDs() (ids []int) {
	for id := range m.airports {
		ids = append(ids, id)
	}
	return
}

// ResetAirports resets all changes to the "airports" edge.
func (m *CityMutation) ResetAirports() {
	m.airports = nil
	m.clearedairports = false
	m.removedairports = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.City, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.state != nil {
		edges = append(edges, city.EdgeState)
	}
	if m.airports != nil {
		edges = append(edges, city.EdgeAirports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.airports))
		for id := range m.airports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedairports != nil {
		edges = append(edges, city.EdgeAirports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.removedairports))
		for id := range m.removedairports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstate {
		edges = append(edges, city.EdgeState)
	}
	if m.clearedairports {
		edges = append(edges, city.EdgeAirports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeState:
		return m.clearedstate
	case city.EdgeAirports:
		return m.clearedairports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeState:
		m.ResetState()
		return nil
	case city.EdgeAirports:
		m.ResetAirports()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Country, error)
	predicates    []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCode:
		return m.Code()
	case country.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Country edge %s", name)
}

// RegionMutation represents an operation that mutates the Region nodes in the graph.
type RegionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	code            *string
	name            *string
	clearedFields   map[string]struct{}
	airports        map[int]struct{}
	removedairports map[int]struct{}
	clearedairports bool
	done            bool
	oldValue        func(context.Context) (*Region, error)
	predicates      []predicate.Region
}

var _ ent.Mutation = (*RegionMutation)(nil)

// regionOption allows management of the mutation configuration using functional options.
type regionOption func(*RegionMutation)

// newRegionMutation creates new mutation for the Region entity.
func newRegionMutation(c config, op Op, opts ...regionOption) *RegionMutation {
	m := &RegionMutation{
		config:        c,
		op:            op,
		typ:           TypeRegion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRegionID sets the ID field of the mutation.
func withRegionID(id int) regionOption {
	return func(m *RegionMutation) {
		var (
			err   error
			once  sync.Once
			value *Region
		)
		m.oldValue = func(ctx context.Context) (*Region, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Region.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRegion sets the old Region of the mutation.
func withRegion(node *Region) regionOption {
	return func(m *RegionMutation) {
		m.oldValue = func(context.Context) (*Region, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RegionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RegionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RegionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RegionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Region.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *RegionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RegionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RegionMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *RegionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RegionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Region entity.
// If the Region object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RegionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RegionMutation) ResetName() {
	m.name = nil
}

// AddAirportIDs adds the "airports" edge to the Airport entity by ids.
func (m *RegionMutation) AddAirportIDs(ids ...int) {
	if m.airports == nil {
		m.airports = make(map[int]struct{})
	}
	for i := range ids {
		m.airports[ids[i]] = struct{}{}
	}
}

// ClearAirports clears the "airports" edge to the Airport entity.
func (m *RegionMutation) ClearAirports() {
	m.clearedairports = true
}

// AirportsCleared reports if the "airports" edge to the Airport entity was cleared.
func (m *RegionMutation) AirportsCleared() bool {
	return m.clearedairports
}

// RemoveAirportIDs removes the "airports" edge to the Airport entity by IDs.
func (m *RegionMutation) RemoveAirportIDs(ids ...int) {
	if m.removedairports == nil {
		m.removedairports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.airports, ids[i])
		m.removedairports[ids[i]] = struct{}{}
	}
}

// RemovedAirports returns the removed IDs of the "airports" edge to the Airport entity.
func (m *RegionMutation) RemovedAirportsIDs() (ids []int) {
	for id := range m.removedairports {
		ids = append(ids, id)
	}
	return
}

// AirportsIDs returns the "airports" edge IDs in the mutation.
func (m *RegionMutation) AirportsIDs() (ids []int) {
	for id := range m.airports {
		ids = append(ids, id)
	}
	return
}

// ResetAirports resets all changes to the "airports" edge.
func (m *RegionMutation) ResetAirports() {
	m.airports = nil
	m.clearedairports = false
	m.removedairports = nil
}

// Where appends a list predicates to the RegionMutation builder.
func (m *RegionMutation) Where(ps ...predicate.Region) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RegionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RegionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Region, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RegionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RegionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Region).
func (m *RegionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RegionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, region.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, region.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RegionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case region.FieldCode:
		return m.Code()
	case region.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RegionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case region.FieldCode:
		return m.OldCode(ctx)
	case region.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Region field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case region.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case region.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RegionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RegionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RegionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Region numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RegionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RegionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RegionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Region nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RegionMutation) ResetField(name string) error {
	switch name {
	case region.FieldCode:
		m.ResetCode()
		return nil
	case region.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Region field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RegionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.airports != nil {
		edges = append(edges, region.EdgeAirports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RegionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.airports))
		for id := range m.airports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RegionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedairports != nil {
		edges = append(edges, region.EdgeAirports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RegionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case region.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.removedairports))
		for id := range m.removedairports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RegionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedairports {
		edges = append(edges, region.EdgeAirports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RegionMutation) EdgeCleared(name string) bool {
	switch name {
	case region.EdgeAirports:
		return m.clearedairports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RegionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Region unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RegionMutation) ResetEdge(name string) error {
	switch name {
	case region.EdgeAirports:
		m.ResetAirports()
		return nil
	}
	return fmt.Errorf("unknown Region edge %s", name)
}

// StateMutation represents an operation that mutates the State nodes in the graph.
type StateMutation struct {
	config
	op              Op
	typ             string
	id              *int
	code            *string
	name            *string
	clearedFields   map[string]struct{}
	cities          map[int]struct{}
	removedcities   map[int]struct{}
	clearedcities   bool
	airports        map[int]struct{}
	removedairports map[int]struct{}
	clearedairports bool
	done            bool
	oldValue        func(context.Context) (*State, error)
	predicates      []predicate.State
}

var _ ent.Mutation = (*StateMutation)(nil)

// stateOption allows management of the mutation configuration using functional options.
type stateOption func(*StateMutation)

// newStateMutation creates new mutation for the State entity.
func newStateMutation(c config, op Op, opts ...stateOption) *StateMutation {
	m := &StateMutation{
		config:        c,
		op:            op,
		typ:           TypeState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStateID sets the ID field of the mutation.
func withStateID(id int) stateOption {
	return func(m *StateMutation) {
		var (
			err   error
			once  sync.Once
			value *State
		)
		m.oldValue = func(ctx context.Context) (*State, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().State.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withState sets the old State of the mutation.
func withState(node *State) stateOption {
	return func(m *StateMutation) {
		m.oldValue = func(context.Context) (*State, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().State.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *StateMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *StateMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *StateMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *StateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the State entity.
// If the State object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StateMutation) ResetName() {
	m.name = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *StateMutation) AddCityIDs(ids ...int) {
	if m.cities == nil {
		m.cities = make(map[int]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *StateMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *StateMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *StateMutation) RemoveCityIDs(ids ...int) {
	if m.removedcities == nil {
		m.removedcities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *StateMutation) RemovedCitiesIDs() (ids []int) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *StateMutation) CitiesIDs() (ids []int) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *StateMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// AddAirportIDs adds the "airports" edge to the Airport entity by ids.
func (m *StateMutation) AddAirportIDs(ids ...int) {
	if m.airports == nil {
		m.airports = make(map[int]struct{})
	}
	for i := range ids {
		m.airports[ids[i]] = struct{}{}
	}
}

// ClearAirports clears the "airports" edge to the Airport entity.
func (m *StateMutation) ClearAirports() {
	m.clearedairports = true
}

// AirportsCleared reports if the "airports" edge to the Airport entity was cleared.
func (m *StateMutation) AirportsCleared() bool {
	return m.clearedairports
}

// RemoveAirportIDs removes the "airports" edge to the Airport entity by IDs.
func (m *StateMutation) RemoveAirportIDs(ids ...int) {
	if m.removedairports == nil {
		m.removedairports = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.airports, ids[i])
		m.removedairports[ids[i]] = struct{}{}
	}
}

// RemovedAirports returns the removed IDs of the "airports" edge to the Airport entity.
func (m *StateMutation) RemovedAirportsIDs() (ids []int) {
	for id := range m.removedairports {
		ids = append(ids, id)
	}
	return
}

// AirportsIDs returns the "airports" edge IDs in the mutation.
func (m *StateMutation) AirportsIDs() (ids []int) {
	for id := range m.airports {
		ids = append(ids, id)
	}
	return
}

// ResetAirports resets all changes to the "airports" edge.
func (m *StateMutation) ResetAirports() {
	m.airports = nil
	m.clearedairports = false
	m.removedairports = nil
}

// Where appends a list predicates to the StateMutation builder.
func (m *StateMutation) Where(ps ...predicate.State) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.State, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (State).
func (m *StateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StateMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, state.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, state.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case state.FieldCode:
		return m.Code()
	case state.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case state.FieldCode:
		return m.OldCode(ctx)
	case state.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown State field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case state.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case state.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown State field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown State numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown State nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StateMutation) ResetField(name string) error {
	switch name {
	case state.FieldCode:
		m.ResetCode()
		return nil
	case state.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown State field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cities != nil {
		edges = append(edges, state.EdgeCities)
	}
	if m.airports != nil {
		edges = append(edges, state.EdgeAirports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case state.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case state.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.airports))
		for id := range m.airports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcities != nil {
		edges = append(edges, state.EdgeCities)
	}
	if m.removedairports != nil {
		edges = append(edges, state.EdgeAirports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case state.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case state.EdgeAirports:
		ids := make([]ent.Value, 0, len(m.removedairports))
		for id := range m.removedairports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcities {
		edges = append(edges, state.EdgeCities)
	}
	if m.clearedairports {
		edges = append(edges, state.EdgeAirports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StateMutation) EdgeCleared(name string) bool {
	switch name {
	case state.EdgeCities:
		return m.clearedcities
	case state.EdgeAirports:
		return m.clearedairports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown State unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StateMutation) ResetEdge(name string) error {
	switch name {
	case state.EdgeCities:
		m.ResetCities()
		return nil
	case state.EdgeAirports:
		m.ResetAirports()
		return nil
	}
	return fmt.Errorf("unknown State edge %s", name)
}
